<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0c0a1d">
  <title>Symptom Tracker</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iNiIgZmlsbD0iIzBjMGExZCIvPgogIDxwYXRoIGQ9Ik02IDE2aDZsMy04IDQgMTYgMy04aDQiIHN0cm9rZT0iIzEwYjk4MSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZmlsbD0ibm9uZSIvPgo8L3N2Zz4K">
  <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iNiIgZmlsbD0iIzBjMGExZCIvPgogIDxwYXRoIGQ9Ik02IDE2aDZsMy04IDQgMTYgMy04aDQiIHN0cm9rZT0iIzEwYjk4MSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZmlsbD0ibm9uZSIvPgo8L3N2Zz4K">
  <link rel="manifest" href="manifest.json">
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { margin: 0; padding: 0; background: #0c0a1d; overflow: hidden; height: 100%; width: 100%; }
    #root { height: 100%; width: 100%; }
    .error-display { color: #f87171; padding: 20px; font-family: monospace; white-space: pre-wrap; background: #1a1333; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel" data-type="module">
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  componentDidCatch(error, errorInfo) {
    this.setState({ error, errorInfo });
    console.error('React Error Boundary caught:', error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-display">
          <h2>Something went wrong</h2>
          <p>{this.state.error?.toString()}</p>
          <details>
            <summary>Stack trace</summary>
            <pre>{this.state.errorInfo?.componentStack}</pre>
          </details>
        </div>
      );
    }
    return this.props.children;
  }
}

const { useState, useRef, useEffect, useMemo, useCallback } = React;

// ============================================================================
// FIREBASE CONFIGURATION (Lazy-loaded)
// ============================================================================
const firebaseConfig = {
  apiKey: "AIzaSyCqkO-WFf7cItkIGRv3iAfH7HDFAN8Ccok",
  authDomain: "symptoms-dae26.firebaseapp.com",
  projectId: "symptoms-dae26",
  storageBucket: "symptoms-dae26.firebasestorage.app",
  messagingSenderId: "469393174412",
  appId: "1:469393174412:web:a40b0fa1239a30091470a9",
  measurementId: "G-DCYZ6J0MPL"
};

// Firebase will be loaded dynamically
let firebaseApp = null;
let firebaseAuth = null;
let firebaseDb = null;
let googleProvider = null;

// Load Firebase SDK from CDN
const loadFirebase = () => {
  return new Promise((resolve, reject) => {
    // Check if already loaded
    if (window.firebase) {
      resolve(window.firebase);
      return;
    }
    
    // Load Firebase App
    const script1 = document.createElement('script');
    script1.src = 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js';
    script1.onload = () => {
      // Load Firebase Auth
      const script2 = document.createElement('script');
      script2.src = 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js';
      script2.onload = () => {
        // Load Firebase Firestore
        const script3 = document.createElement('script');
        script3.src = 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js';
        script3.onload = () => {
          resolve(window.firebase);
        };
        script3.onerror = reject;
        document.head.appendChild(script3);
      };
      script2.onerror = reject;
      document.head.appendChild(script2);
    };
    script1.onerror = reject;
    document.head.appendChild(script1);
  });
};

// Initialize Firebase (called after SDK loads)
const initFirebase = async () => {
  try {
    const firebase = await loadFirebase();
    
    if (!firebase.apps.length) {
      firebaseApp = firebase.initializeApp(firebaseConfig);
    } else {
      firebaseApp = firebase.apps[0];
    }
    
    firebaseAuth = firebase.auth();
    firebaseDb = firebase.firestore();
    googleProvider = new firebase.auth.GoogleAuthProvider();
    
    // Set auth persistence for better mobile support
    await firebaseAuth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    
    // Enable Firestore offline persistence
    try {
      await firebaseDb.enablePersistence({ synchronizeTabs: true });
    } catch (err) {
      if (err.code === 'failed-precondition') {
        console.log('Firestore persistence failed: multiple tabs open');
      } else if (err.code === 'unimplemented') {
        console.log('Firestore persistence not supported in this browser');
      }
    }
    
    return { auth: firebaseAuth, db: firebaseDb, provider: googleProvider };
  } catch (error) {
    console.error('Failed to load Firebase:', error);
    return null;
  }
};

// Detect if on mobile
const isMobile = () => {
  return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
};

// Detect if running as PWA (standalone mode)
const isStandalone = () => {
  return window.matchMedia('(display-mode: standalone)').matches ||
         window.navigator.standalone === true ||
         document.referrer.includes('android-app://');
};

// Check if Firebase Auth is supported in current environment
const isAuthSupported = () => {
  // Must be http/https (not file://)
  const validProtocol = window.location.protocol === 'http:' || window.location.protocol === 'https:';
  
  // Check if localStorage is available
  let storageAvailable = false;
  try {
    localStorage.setItem('test', 'test');
    localStorage.removeItem('test');
    storageAvailable = true;
  } catch (e) {
    storageAvailable = false;
  }
  
  // Safari standalone mode doesn't support OAuth
  const notStandalone = !isStandalone();
  
  return validProtocol && storageAvailable && notStandalone;
};

// ============================================================================
// SYMPTOM TRACKER v3.1
// ============================================================================
// A mobile-first health tracking app for symptoms and supplements.
//
// FILE STRUCTURE:
// 1. Configuration & Constants (lines ~15-220)
// 2. Main Component (line ~225)
//    - State declarations
//    - Effects (localStorage, scroll lock)
//    - Helper functions (date formatting, data manipulation)
//    - Event handlers (touch/mouse, navigation)
//    - Data functions (insights, export, backup)
//    - Render (UI components)
// ============================================================================

// ============================================================================
// DEFAULT DATA
// ============================================================================
const defaultSymptoms = [
  { id: 'red-neck-chest', name: 'Red neck/chest, blotchy skin tone', active: true, order: 0 },
  { id: 'penile-retraction', name: 'Penile retraction', active: true, order: 1 },
  { id: 'pee-dribble', name: 'Pee dribble', active: true, order: 2 },
  { id: 'urinary-urgency', name: 'Urinary urgency', active: true, order: 3 },
  { id: 'daytime-fatigue', name: 'Daytime fatigue', active: true, order: 4 },
  { id: 'irritability', name: 'Irritability', active: true, order: 5 },
  { id: 'social-withdrawal', name: 'Social withdrawal', active: true, order: 6 },
  { id: 'air-hunger-am', name: 'Air hunger AM', active: true, order: 7 },
  { id: 'anxiety-mental', name: 'Anxiety (mental: racing thoughts etc.)', active: true, order: 8 },
  { id: 'anxiety-physical', name: 'Anxiety (physical: chest pressure etc.)', active: true, order: 9 },
  { id: 'low-sexual-drive', name: 'Low sexual drive', active: true, order: 10 },
  { id: 'nerve-pain', name: 'Nerve pain / neuropathy', active: true, order: 11 },
  { id: 'headache', name: 'Headache', active: true, order: 12 },
  { id: 'dysphagia', name: 'Dysphagia', active: true, order: 13 },
  { id: 'fascial-tightness', name: 'Fascial and tendon tightness', active: true, order: 14 },
  { id: 'psoriasis', name: 'Psoriasis', active: true, order: 15 },
  { id: 'skinny-stool', name: 'Skinny stool', active: true, order: 16 },
  { id: 'diarrhea', name: 'Diarrhea / Loose stool', active: true, order: 17 },
  { id: 'brain-fog', name: 'Brain fog', active: true, order: 18 },
  { id: 'sugar-cravings', name: 'Sugar / alcohol cravings', active: true, order: 19 },
  { id: 'heartburn', name: 'Heartburn / bile reflux', active: true, order: 20 },
  { id: 'oral-thrush', name: 'Oral thrush', active: true, order: 21 },
  { id: 'farting-burping', name: 'Farting, burping', active: true, order: 22 },
  { id: 'cracking-joints', name: 'Cracking joints', active: true, order: 23 },
  { id: 'air-hunger-pm', name: 'Air hunger PM', active: true, order: 24 },
];

const defaultStackItems = [
  { id: 'b1-benfotiamine', name: 'B1 Benfotiamine', unit: 'mg', defaultDose: 200, active: true, order: 0 },
  { id: 'b2', name: 'B2', unit: 'mg', defaultDose: 250, active: true, order: 1 },
  { id: 'b3', name: 'B3', unit: 'mg', defaultDose: 50, active: true, order: 2 },
  { id: 'l-methylfolate', name: 'L-methylfolate', unit: 'mcg', defaultDose: 200, active: true, order: 3 },
  { id: 'methyl-b12', name: 'Methyl-B12', unit: 'mcg', defaultDose: 250, active: true, order: 4 },
  { id: 'd3', name: 'D3', unit: 'IU', defaultDose: 5000, active: true, order: 5 },
  { id: 'quercetin', name: 'Quercetin', unit: 'mg', defaultDose: 500, active: true, order: 6 },
  { id: 'vitamin-c', name: 'Vitamin C', unit: 'mg', defaultDose: 2000, active: true, order: 7 },
  { id: 'glycine', name: 'Glycine', unit: 'g', defaultDose: 3, active: true, order: 8 },
  { id: 'magnesium', name: 'Magnesium (biglycinate + threonate)', unit: 'mg', defaultDose: 600, active: true, order: 9 },
  { id: 'butyrate', name: 'Butyrate', unit: 'mg', defaultDose: 200, active: true, order: 10 },
  { id: 'ketotifen', name: 'Ketotifen', unit: 'mg', defaultDose: 1, active: true, order: 11 },
];

// ============================================================================
// STORAGE KEYS
// ============================================================================
const STORAGE_KEY_SYMPTOMS = 'symptomTracker_symptoms';
const STORAGE_KEY_ENTRIES = 'symptomTracker_entries';
const STORAGE_KEY_NOTES = 'symptomTracker_notes';
const STORAGE_KEY_MODE = 'symptomTracker_mode';
const STORAGE_KEY_APP_MODE = 'symptomTracker_appMode';
const STORAGE_KEY_STACK_ITEMS = 'symptomTracker_stackItems';
const STORAGE_KEY_STACK_ENTRIES = 'symptomTracker_stackEntries';
const STORAGE_KEY_PINNED = 'symptomTracker_pinned';

// ============================================================================
// TIME PERIODS & TRACKING MODES
// ============================================================================
const trackingModes = {
  simple: {
    label: 'Simple',
    description: 'One entry per day',
    periods: [{ id: 'daily', label: 'Daily', icon: 'â—‹' }],
  },
  ampm: {
    label: 'AM/PM',
    description: 'Morning and evening',
    periods: [
      { id: 'morning', label: 'AM', icon: 'â—' },
      { id: 'evening', label: 'PM', icon: 'â—‘' },
    ],
  },
};

// ============================================================================
// SEVERITY CONFIGURATION
// ============================================================================
const severityLevels = [0, 1, 2, 3, 4, 5];
const severityColors = {
  0: '#22c55e',
  1: '#4ade80',
  2: '#a3e635',
  3: '#facc15',
  4: '#fb923c',
  5: '#ef4444',
};
const severityLabels = ['None', 'Minimal', 'Mild', 'Moderate', 'Severe', 'Extreme'];

// ============================================================================
// SAMPLE DATA GENERATOR
// ============================================================================
const generateSampleData = (symptoms, mode = 'ampm') => {
  const entries = {};
  const today = new Date();
  const periods = trackingModes[mode].periods;
  
  // Define symptom clusters that tend to appear together
  const clusters = {
    fatigue: ['daytime-fatigue', 'brain-fog', 'air-hunger-am', 'air-hunger-pm'],
    anxiety: ['anxiety-mental', 'anxiety-physical', 'irritability', 'social-withdrawal'],
    digestive: ['heartburn', 'diarrhea', 'skinny-stool', 'farting-burping', 'oral-thrush'],
    urinary: ['urinary-urgency', 'pee-dribble', 'penile-retraction'],
    pain: ['headache', 'nerve-pain', 'fascial-tightness'],
  };
  
  // Monthly trend modifiers (6 months back) - some symptoms improve, some worsen
  const monthlyTrends = {
    'headache': [1.5, 1.3, 1.2, 1.0, 0.8, 0.7], // improving
    'brain-fog': [1.4, 1.3, 1.1, 1.0, 0.9, 0.8], // improving
    'heartburn': [1.2, 1.0, 0.8, 1.0, 1.2, 1.0], // cyclical
    'daytime-fatigue': [1.0, 1.0, 1.0, 1.0, 1.0, 1.0], // stable
    'psoriasis': [0.5, 0.6, 0.8, 1.0, 1.2, 1.3], // worsening
    'irritability': [0.7, 0.8, 0.9, 1.0, 1.1, 1.2], // worsening
    'anxiety-mental': [1.3, 1.2, 1.1, 1.0, 0.9, 0.8], // improving
    'diarrhea': [1.0, 1.1, 0.9, 1.0, 0.8, 1.2], // cyclical
  };

  // Weekly patterns (0 = Sunday)
  const weekendEffect = {
    'headache': [1.2, 1.1, 0.9, 0.9, 0.9, 1.0, 1.1], // Monday headaches
    'anxiety-mental': [0.8, 1.2, 1.1, 1.0, 1.0, 0.9, 0.8], // Weekday anxiety
  };
  
  for (let daysAgo = 0; daysAgo < 180; daysAgo++) {
    const date = new Date(today);
    date.setDate(date.getDate() - daysAgo);
    const dateKey = date.toISOString().split('T')[0];
    const monthsAgo = Math.floor(daysAgo / 30);
    const dayOfWeek = date.getDay();
    
    if (Math.random() < 0.85) {
      // Pick 2-4 symptoms, with cluster correlation
      let selectedSymptomIds = [];
      const activeSymptoms = symptoms.filter(s => s.active);
      
      // 40% chance to activate a cluster
      if (Math.random() < 0.4) {
        const clusterNames = Object.keys(clusters);
        const cluster = clusters[clusterNames[Math.floor(Math.random() * clusterNames.length)]];
        const clusterSymptoms = cluster.filter(id => 
          activeSymptoms.some(s => s.id === id)
        );
        if (clusterSymptoms.length > 0) {
          const numFromCluster = Math.min(clusterSymptoms.length, Math.floor(Math.random() * 2) + 1);
          selectedSymptomIds = clusterSymptoms.slice(0, numFromCluster);
        }
      }
      
      // Add random symptoms
      const numAdditional = Math.floor(Math.random() * 2) + 1;
      const otherSymptoms = activeSymptoms
        .filter(s => !selectedSymptomIds.includes(s.id))
        .sort(() => Math.random() - 0.5)
        .slice(0, numAdditional)
        .map(s => s.id);
      
      selectedSymptomIds = [...selectedSymptomIds, ...otherSymptoms];
      
      selectedSymptomIds.forEach(symptomId => {
        const numPeriods = mode === 'simple' ? 1 : (Math.random() < 0.7 ? 1 : 2);
        const shuffledPeriods = [...periods].sort(() => Math.random() - 0.5).slice(0, numPeriods);
        
        shuffledPeriods.forEach(period => {
          let baseSeverity = Math.floor(Math.random() * 4) + 1;
          
          // Apply monthly trend
          const trend = monthlyTrends[symptomId];
          if (trend && monthsAgo < trend.length) {
            baseSeverity = Math.round(baseSeverity * trend[monthsAgo]);
          }
          
          // Apply weekly pattern
          const weekPattern = weekendEffect[symptomId];
          if (weekPattern) {
            baseSeverity = Math.round(baseSeverity * weekPattern[dayOfWeek]);
          }
          
          // Morning symptoms tend to be worse for some
          if (period.id === 'morning' && ['headache', 'air-hunger-am'].includes(symptomId)) {
            baseSeverity = Math.min(5, baseSeverity + 1);
          }
          
          const key = `${dateKey}-${symptomId}-${period.id}`;
          entries[key] = {
            time: period.id,
            severity: Math.min(5, Math.max(1, baseSeverity)),
            date: dateKey,
            symptomId: symptomId
          };
        });
      });
    }
  }
  
  return entries;
};

function SymptomTrackerMobile() {
  // ==========================================================================
  // STATE DECLARATIONS
  // ==========================================================================
  
  // App mode: 'symptoms' or 'stack' - always start on symptoms
  const [appMode, setAppMode] = useState('symptoms');
  
  const [symptoms, setSymptoms] = useState(() => {
    const saved = localStorage.getItem(STORAGE_KEY_SYMPTOMS);
    return saved ? JSON.parse(saved) : defaultSymptoms;
  });
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [entries, setEntries] = useState(() => {
    const saved = localStorage.getItem(STORAGE_KEY_ENTRIES);
    return saved ? JSON.parse(saved) : {};
  });
  
  // Daily notes - keyed by date string (YYYY-MM-DD)
  const [dailyNotes, setDailyNotes] = useState(() => {
    const saved = localStorage.getItem(STORAGE_KEY_NOTES);
    return saved ? JSON.parse(saved) : {};
  });
  
  // Stack state
  const [stackItems, setStackItems] = useState(() => {
    const saved = localStorage.getItem(STORAGE_KEY_STACK_ITEMS);
    return saved ? JSON.parse(saved) : defaultStackItems;
  });
  const [stackEntries, setStackEntries] = useState(() => {
    const saved = localStorage.getItem(STORAGE_KEY_STACK_ENTRIES);
    return saved ? JSON.parse(saved) : {};
  });
  const [editingStackItem, setEditingStackItem] = useState(null);
  const [showManageStack, setShowManageStack] = useState(false);
  const [showAddStackItem, setShowAddStackItem] = useState(false);
  const [newStackItem, setNewStackItem] = useState({ name: '', unit: 'mg', defaultDose: '' });
  
  // Pinned symptoms (favorites that show at top)
  const [pinnedSymptoms, setPinnedSymptoms] = useState(() => {
    const saved = localStorage.getItem(STORAGE_KEY_PINNED);
    return saved ? new Set(JSON.parse(saved)) : new Set();
  });
  
  const [hasSampleData, setHasSampleData] = useState(false);
  const [trackingMode, setTrackingMode] = useState(() => {
    const saved = localStorage.getItem(STORAGE_KEY_MODE);
    return saved || 'ampm';
  });
  const [showInsights, setShowInsights] = useState(false);
  const [insightsWindow, setInsightsWindow] = useState(60);
  
  // Derived time periods based on mode
  const timePeriods = trackingModes[trackingMode].periods;
  
  const [activeSymptom, setActiveSymptom] = useState(null);
  const [dragPosition, setDragPosition] = useState({ x: 2, y: 2 });
  const [isDragging, setIsDragging] = useState(false);
  const [fingerPosition, setFingerPosition] = useState({ x: 0, y: 0 });
  const [lastAction, setLastAction] = useState('');
  const [showAddSymptom, setShowAddSymptom] = useState(false);
  const [showCalendar, setShowCalendar] = useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const [showExport, setShowExport] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [openedFromSettings, setOpenedFromSettings] = useState(false);
  const [confirmClearData, setConfirmClearData] = useState(false);
  const [confirmFullReset, setConfirmFullReset] = useState(false);
  const [editingSymptomId, setEditingSymptomId] = useState(null);
  const [editingSymptomName, setEditingSymptomName] = useState('');
  const [editingStackItemId, setEditingStackItemId] = useState(null);
  const [editingStackItemData, setEditingStackItemData] = useState({ name: '', defaultDose: '', unit: 'mg' });
  const [bulkSymptomInput, setBulkSymptomInput] = useState('');
  const [calendarMonth, setCalendarMonth] = useState(new Date());
  const [historySort, setHistorySort] = useState({ column: 'date', direction: 'desc' });
  const [symptomSearch, setSymptomSearch] = useState('');
  const [searchVisible, setSearchVisible] = useState(false); // Hidden by default
  const [showCompletion, setShowCompletion] = useState(false); // Completion animation
  const [lastDeletedEntry, setLastDeletedEntry] = useState(null); // For undo functionality
  const [isLoading, setIsLoading] = useState(false); // For loading states
  const [quickLogSymptom, setQuickLogSymptom] = useState(null); // For tap-to-log quick picker
  const [quickLogTime, setQuickLogTime] = useState(null); // Selected time period in quick picker (null = first period)
  const [rapidEntryMode, setRapidEntryMode] = useState(false); // Rapid entry mode
  const [rapidEntryConfirm, setRapidEntryConfirm] = useState(false); // Confirm start over
  const [rapidEntryLogged, setRapidEntryLogged] = useState([]); // Track logged symptoms for back button
  const [rapidEntryIndex, setRapidEntryIndex] = useState(0); // Current symptom index in rapid entry
  
  // Drag-to-reorder state
  const [draggedItem, setDraggedItem] = useState(null); // { id, type: 'symptom' | 'stack', startIndex }
  const [dragOverIndex, setDragOverIndex] = useState(null);
  const [dragY, setDragY] = useState(0); // Current Y offset for dragged item
  const dragStartY = useRef(0);
  const dragItemHeight = useRef(48); // Approximate item height
  
  // Swipe-to-delete state
  const [swipeOffsets, setSwipeOffsets] = useState({}); // { [itemId]: offsetX }
  
  // Firebase Auth State
  const [user, setUser] = useState(null);
  const [authLoading, setAuthLoading] = useState(true);
  const [syncing, setSyncing] = useState(false);
  const [lastSynced, setLastSynced] = useState(null);
  const [syncError, setSyncError] = useState(null);
  const [authEmail, setAuthEmail] = useState('');
  const [authPassword, setAuthPassword] = useState('');
  const [isSignUp, setIsSignUp] = useState(false);
  
  // Refs
  const containerRef = useRef(null);
  const startPosRef = useRef({ x: 0, y: 0 });
  const holdTimerRef = useRef(null);
  const pendingSymptomRef = useRef(null);
  const isDraggingRef = useRef(false);
  const swipeStartRef = useRef({ x: 0, y: 0, time: 0, id: null }); // Combined: time for nav swipe, id for delete swipe
  const notesTextareaRef = useRef(null);

  // Constants
  const DRAG_SENSITIVITY = 19;
  const HOLD_DELAY = 200;
  const SWIPE_THRESHOLD = 50; // minimum px for swipe
  const SWIPE_TIME_LIMIT = 300; // max ms for swipe gesture

  // ==========================================================================
  // MEMOIZED VALUES
  // ==========================================================================
  
  // Helper function for date keys (defined early for use in memos)
  const getDateKey = useCallback((date) => date.toISOString().split('T')[0], []);
  
  // Helper function to get current time period based on hour (for AM/PM mode)
  const getCurrentTimePeriod = useCallback(() => {
    if (trackingMode !== 'ampm') return 'daily';
    const hour = new Date().getHours();
    // Before 12pm = morning, 12pm and after = evening
    return hour < 12 ? 'morning' : 'evening';
  }, [trackingMode]);
  
  const activeSymptoms = useMemo(() => {
    let active = symptoms.filter(s => s.active);
    if (symptomSearch.trim()) {
      const search = symptomSearch.toLowerCase();
      active = active.filter(s => s.name.toLowerCase().includes(search));
    }
    // Sort: pinned first, then by order
    return active.sort((a, b) => {
      const aPinned = pinnedSymptoms.has(a.id);
      const bPinned = pinnedSymptoms.has(b.id);
      if (aPinned && !bPinned) return -1;
      if (!aPinned && bPinned) return 1;
      return (a.order || 0) - (b.order || 0);
    });
  }, [symptoms, symptomSearch, pinnedSymptoms]);
  
  // Incomplete symptoms for rapid entry - only symptoms not logged for the current time period
  const incompleteSymptoms = useMemo(() => {
    const dateKey = selectedDate.toISOString().split('T')[0];
    // Use the current rapid entry time period, or calculate based on time of day
    const timePeriod = quickLogTime || (new Date().getHours() < 12 ? 'morning' : 'evening');
    
    // Get active symptoms without search filter for rapid entry
    const allActive = symptoms.filter(s => s.active).sort((a, b) => {
      const aPinned = pinnedSymptoms.has(a.id);
      const bPinned = pinnedSymptoms.has(b.id);
      if (aPinned && !bPinned) return -1;
      if (!aPinned && bPinned) return 1;
      return (a.order || 0) - (b.order || 0);
    });
    
    return allActive.filter(symptom => {
      // Check if this symptom has an entry for today's time period
      const entryKey = trackingMode === 'ampm' 
        ? `${dateKey}-${symptom.id}-${timePeriod}`
        : `${dateKey}-${symptom.id}-daily`;
      return !entries[entryKey];
    });
  }, [symptoms, entries, selectedDate, quickLogTime, trackingMode, pinnedSymptoms]);
  
  // All active symptoms count for checking completion
   const totalActiveSymptoms = useMemo(() => 
    symptoms.filter(s => s.active).length,
    [symptoms]
  );
  
  // Track if user just logged a symptom (to distinguish from date navigation)
  const justLoggedRef = useRef(false);
  
  // Track previous incomplete count for completion detection
  const prevIncompleteRef = useRef(incompleteSymptoms.length);
  const prevDateRef = useRef(selectedDate.toISOString());
  
  // Detect when all symptoms become complete (only from logging, not navigation)
  useEffect(() => {
    const prevCount = prevIncompleteRef.current;
    const currentCount = incompleteSymptoms.length;
    const dateChanged = prevDateRef.current !== selectedDate.toISOString();
    
    // Only show completion if:
    // 1. We went from some incomplete to none
    // 2. We have active symptoms
    // 3. User just logged a symptom (not navigating dates)
    if (prevCount > 0 && currentCount === 0 && totalActiveSymptoms > 0 && justLoggedRef.current && !dateChanged) {
      setShowCompletion(true);
      // Auto-hide after 2 seconds
      const timer = setTimeout(() => setShowCompletion(false), 2000);
      justLoggedRef.current = false;
      return () => clearTimeout(timer);
    }
    
    // Reset the flag if date changed
    if (dateChanged) {
      justLoggedRef.current = false;
    }
    
    prevIncompleteRef.current = currentCount;
    prevDateRef.current = selectedDate.toISOString();
  }, [incompleteSymptoms.length, totalActiveSymptoms, selectedDate]);
  
  // Helper to mark that user just logged
  const markJustLogged = useCallback(() => {
    justLoggedRef.current = true;
  }, []);
  
  const inactiveSymptoms = useMemo(() => 
    symptoms.filter(s => !s.active), 
    [symptoms]
  );
  
  const daysWithEntries = useMemo(() => {
    const days = new Set();
    Object.values(entries).forEach(entry => days.add(entry.date));
    return days;
  }, [entries]);

  // Calendar heat map data - average severity per day
  const daySeverityMap = useMemo(() => {
    const map = {};
    Object.values(entries).forEach(entry => {
      if (!map[entry.date]) {
        map[entry.date] = { total: 0, count: 0 };
      }
      map[entry.date].total += entry.severity;
      map[entry.date].count += 1;
    });
    // Calculate averages
    Object.keys(map).forEach(date => {
      map[date].avg = map[date].total / map[date].count;
    });
    return map;
  }, [entries]);

  // Streak counter - consecutive days with entries
  const streak = useMemo(() => {
    let count = 0;
    const today = new Date();
    let checkDate = new Date(today);
    
    while (true) {
      const dateKey = checkDate.toISOString().split('T')[0];
      if (daysWithEntries.has(dateKey)) {
        count++;
        checkDate.setDate(checkDate.getDate() - 1);
      } else {
        break;
      }
    }
    return count;
  }, [daysWithEntries]);

  // Today's overall severity average
  const todayAvgSeverity = useMemo(() => {
    const dateKey = getDateKey(selectedDate);
    const todayEntries = Object.values(entries).filter(e => e.date === dateKey);
    if (todayEntries.length === 0) return null;
    return todayEntries.reduce((sum, e) => sum + e.severity, 0) / todayEntries.length;
  }, [entries, selectedDate]);

  // Tab badge data - status colors
  const tabBadges = useMemo(() => {
    const dateKey = getDateKey(selectedDate);
    const todaySymptomEntries = Object.values(entries).filter(e => e.date === dateKey);
    const todayStackEntries = Object.values(stackEntries).filter(e => e.date === dateKey);
    const activeStackCount = stackItems.filter(i => i.active).length;
    const activeSymptomCount = symptoms.filter(s => s.active).length;
    
    // Calculate status: 'none', 'some', 'all'
    const symptomStatus = todaySymptomEntries.length === 0 ? 'none' 
      : todaySymptomEntries.length >= activeSymptomCount ? 'all' : 'some';
    const stackStatus = todayStackEntries.length === 0 ? 'none'
      : todayStackEntries.length >= activeStackCount ? 'all' : 'some';
    
    return {
      symptoms: { count: todaySymptomEntries.length, total: activeSymptomCount, status: symptomStatus },
      stack: { taken: todayStackEntries.length, total: activeStackCount, status: stackStatus },
    };
  }, [entries, stackEntries, stackItems, symptoms, selectedDate]);

  // Status dot colors
  const statusColors = { none: '#ef4444', some: '#fbbf24', all: '#4ade80' };

  // ==========================================================================
  // EFFECTS
  // ==========================================================================

  // Firebase Initialization & Auth State Listener
  const [firebaseReady, setFirebaseReady] = useState(false);
  const [firebaseError, setFirebaseError] = useState(null);
  
  useEffect(() => {
    let unsubscribe = null;
    let timeoutId = null;
    
    const setupFirebase = async () => {
      try {
        // Set timeout - if Firebase doesn't load in 5 seconds, show error
        timeoutId = setTimeout(() => {
          if (!firebaseReady) {
            setFirebaseError('Firebase blocked - cloud sync unavailable in this environment');
            setAuthLoading(false);
          }
        }, 5000);
        
        const firebase = await initFirebase();
        clearTimeout(timeoutId);
        
        if (firebase) {
          setFirebaseReady(true);
          
          // Check for redirect result (for mobile sign-in)
          try {
            const result = await firebase.auth.getRedirectResult();
            if (result.user) {
              console.log('Redirect sign-in successful');
            }
          } catch (redirectError) {
            console.log('No redirect result or error:', redirectError.message);
          }
          
          unsubscribe = firebase.auth.onAuthStateChanged(async (firebaseUser) => {
            setUser(firebaseUser);
            setAuthLoading(false);
            
            // If user just signed in, load their data from Firestore
            if (firebaseUser) {
              await loadFromCloud(firebaseUser.uid);
            }
          });
        } else {
          setFirebaseError('Firebase failed to initialize');
          setAuthLoading(false);
        }
      } catch (error) {
        console.error('Firebase setup error:', error);
        setFirebaseError(error.message);
        setAuthLoading(false);
      }
    };
    
    setupFirebase();
    
    return () => {
      if (unsubscribe) unsubscribe();
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, []);

  // Keep ref in sync with state
  useEffect(() => {
    isDraggingRef.current = isDragging;
  }, [isDragging]);

  // Auto-clear lastAction after 3 seconds
  useEffect(() => {
    if (lastAction) {
      const timer = setTimeout(() => {
        setLastAction('');
      }, 3000);
      return () => clearTimeout(timer);
    }
  }, [lastAction]);

  // Reset confirmClearData and confirmFullReset when leaving Settings
  useEffect(() => {
    if (!showSettings) {
      setConfirmClearData(false);
      setConfirmFullReset(false);
    }
  }, [showSettings]);

  // Persist state to localStorage
  useEffect(() => {
    localStorage.setItem(STORAGE_KEY_SYMPTOMS, JSON.stringify(symptoms));
  }, [symptoms]);
  
  useEffect(() => {
    localStorage.setItem(STORAGE_KEY_ENTRIES, JSON.stringify(entries));
  }, [entries]);
  
  useEffect(() => {
    localStorage.setItem(STORAGE_KEY_NOTES, JSON.stringify(dailyNotes));
  }, [dailyNotes]);
  
  useEffect(() => {
    localStorage.setItem(STORAGE_KEY_MODE, trackingMode);
  }, [trackingMode]);
  
  useEffect(() => {
    localStorage.setItem(STORAGE_KEY_APP_MODE, appMode);
  }, [appMode]);
  
  useEffect(() => {
    localStorage.setItem(STORAGE_KEY_STACK_ITEMS, JSON.stringify(stackItems));
  }, [stackItems]);
  
  useEffect(() => {
    localStorage.setItem(STORAGE_KEY_STACK_ENTRIES, JSON.stringify(stackEntries));
  }, [stackEntries]);

  useEffect(() => {
    localStorage.setItem(STORAGE_KEY_PINNED, JSON.stringify([...pinnedSymptoms]));
  }, [pinnedSymptoms]);

  // Auto-sync to cloud when data changes (debounced)
  const syncTimeoutRef = useRef(null);
  const lastSyncDataRef = useRef('');
  
  useEffect(() => {
    // Only auto-sync if user is signed in and Firebase is ready
    if (!user || !firebaseDb || syncing) return;
    
    // Create a hash of current data to detect changes
    const currentData = JSON.stringify({
      symptoms, entries, dailyNotes, stackItems, stackEntries, pinnedSymptoms: [...pinnedSymptoms], trackingMode
    });
    
    // Skip if data hasn't changed since last sync
    if (currentData === lastSyncDataRef.current) return;
    
    // Clear existing timeout
    if (syncTimeoutRef.current) {
      clearTimeout(syncTimeoutRef.current);
    }
    
    // Debounce: sync 5 seconds after last change
    syncTimeoutRef.current = setTimeout(async () => {
      try {
        setSyncing(true);
        const docRef = firebaseDb.collection('users').doc(user.uid);
        await docRef.set({
          symptoms,
          entries,
          dailyNotes,
          stackItems,
          stackEntries,
          pinnedSymptoms: [...pinnedSymptoms],
          trackingMode,
          version: '3.1',
          updatedAt: window.firebase.firestore.FieldValue.serverTimestamp(),
        });
        lastSyncDataRef.current = currentData;
        setLastSynced(new Date());
        setSyncError(null);
      } catch (err) {
        console.error('Auto-sync error:', err);
        if (err.code === 'permission-denied') {
          setSyncError('Permission denied - check Firestore rules');
        } else if (!err.message?.includes('offline')) {
          setSyncError('Sync failed - will retry');
        }
      } finally {
        setSyncing(false);
      }
    }, 5000); // 5 second delay
    
    return () => {
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
      }
    };
  }, [user, firebaseDb, symptoms, entries, dailyNotes, stackItems, stackEntries, pinnedSymptoms, trackingMode, syncing]);

  // Lock body scroll when dragging - iOS Safari fix
  useEffect(() => {
    const preventScroll = (e) => {
      if (isDraggingRef.current) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    };
    
    // Add listener once with passive: false
    document.addEventListener('touchmove', preventScroll, { passive: false });
    
    return () => {
      document.removeEventListener('touchmove', preventScroll);
    };
  }, []);

  // Manage body class for scroll lock
  useEffect(() => {
    if (isDragging) {
      document.body.classList.add('no-scroll');
      document.documentElement.style.overflow = 'hidden';
    } else {
      document.body.classList.remove('no-scroll');
      document.documentElement.style.overflow = '';
    }
    return () => {
      document.body.classList.remove('no-scroll');
      document.documentElement.style.overflow = '';
    };
  }, [isDragging]);

  // Auto-copy yesterday's stack when viewing today with no entries
  useEffect(() => {
    const todayKey = getDateKey(new Date());
    const selectedKey = getDateKey(selectedDate);
    
    // Only auto-copy if we're viewing today
    if (selectedKey !== todayKey) return;
    
    // Check if today has any stack entries
    const hasTodayEntries = Object.keys(stackEntries).some(key => key.startsWith(todayKey + '-'));
    if (hasTodayEntries) return;
    
    // Get yesterday's entries
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayKey = getDateKey(yesterday);
    
    const activeItems = stackItems.filter(item => item.active);
    if (activeItems.length === 0) return;
    
    // Copy yesterday's taken items to today
    const newEntries = { ...stackEntries };
    let copiedCount = 0;
    
    activeItems.forEach(item => {
      const yesterdayEntryKey = `${yesterdayKey}-${item.id}`;
      const todayEntryKey = `${todayKey}-${item.id}`;
      
      const yesterdayEntry = stackEntries[yesterdayEntryKey];
      if (yesterdayEntry && yesterdayEntry.taken) {
        newEntries[todayEntryKey] = { 
          ...yesterdayEntry, 
          date: todayKey 
        };
        copiedCount++;
      }
    });
    
    if (copiedCount > 0) {
      setStackEntries(newEntries);
      setLastAction(`Auto-copied ${copiedCount} items from yesterday`);
    }
  }, [selectedDate, stackItems]); // Only depend on date and items, not entries to avoid loops

  // Midnight check - auto-switch to today when date changes
  useEffect(() => {
    const checkMidnight = () => {
      const now = new Date();
      const currentDateKey = getDateKey(now);
      const selectedKey = getDateKey(selectedDate);
      
      // If we're viewing yesterday (or earlier) and it's now a new day, switch to today
      if (selectedKey < currentDateKey) {
        setSelectedDate(new Date());
      }
    };
    
    // Check every minute
    const interval = setInterval(checkMidnight, 60000);
    
    // Also check on visibility change (when app becomes visible)
    const handleVisibility = () => {
      if (document.visibilityState === 'visible') {
        checkMidnight();
      }
    };
    document.addEventListener('visibilitychange', handleVisibility);
    
    return () => {
      clearInterval(interval);
      document.removeEventListener('visibilitychange', handleVisibility);
    };
  }, [selectedDate, getDateKey]);

  // Keyboard shortcuts for rapid entry mode
  useEffect(() => {
    if (!rapidEntryMode || rapidEntryConfirm) return;
    
    const handleKeyDown = (e) => {
      // Number keys 0-5 to log severity
      if (e.key >= '0' && e.key <= '5') {
        const severity = parseInt(e.key);
        const symptomId = incompleteSymptoms[rapidEntryIndex]?.id;
        const symptomName = incompleteSymptoms[rapidEntryIndex]?.name;
        if (symptomId) {
          const logTime = quickLogTime || getCurrentTimePeriod();
          
          // Track for undo
          setRapidEntryLogged(prev => [...prev, {
            symptomId,
            symptomName,
            severity,
            time: logTime,
          }]);
          
          quickLog(symptomId, severity, logTime);
          
          // Check if this was the last one
          if (incompleteSymptoms.length <= 1) {
            setRapidEntryMode(false);
            setRapidEntryIndex(0);
            setLastAction(`âš¡ Rapid entry complete`);
          }
        }
      }
      // Escape to close
      else if (e.key === 'Escape') {
        setRapidEntryMode(false);
        setRapidEntryIndex(0);
        setRapidEntryConfirm(false);
      }
      // Backspace or Left arrow to undo
      else if ((e.key === 'Backspace' || e.key === 'ArrowLeft') && rapidEntryLogged.length > 0) {
        e.preventDefault();
        const lastLogged = rapidEntryLogged[rapidEntryLogged.length - 1];
        const dateKey = selectedDate.toISOString().split('T')[0];
        const timeKey = trackingMode === 'ampm' ? lastLogged.time : 'daily';
        const entryKey = `${dateKey}-${lastLogged.symptomId}-${timeKey}`;
        
        setEntries(prev => {
          const newEntries = { ...prev };
          delete newEntries[entryKey];
          return newEntries;
        });
        
        setRapidEntryLogged(prev => prev.slice(0, -1));
      }
      // Right arrow to skip/close
      else if (e.key === 'ArrowRight') {
        setRapidEntryMode(false);
        setRapidEntryIndex(0);
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [rapidEntryMode, rapidEntryConfirm, rapidEntryIndex, incompleteSymptoms, quickLogTime, quickLog, getCurrentTimePeriod, rapidEntryLogged, selectedDate, trackingMode]);

  // ==========================================================================
  // FIREBASE SYNC FUNCTIONS
  // ==========================================================================

  // Save all data to Firestore
  const saveToCloud = useCallback(async () => {
    if (!user || !firebaseDb) return;
    
    setSyncing(true);
    setSyncError(null);
    
    try {
      const userData = {
        symptoms,
        entries,
        dailyNotes,
        stackItems,
        stackEntries,
        trackingMode,
        pinnedSymptoms: [...pinnedSymptoms],
        updatedAt: window.firebase.firestore.FieldValue.serverTimestamp(),
        version: '3.1',
      };
      
      await firebaseDb.collection('users').doc(user.uid).set(userData);
      setLastSynced(new Date());
      setLastAction('â˜ï¸ Saved to cloud');
    } catch (error) {
      console.error('Error saving to cloud:', error);
      // Handle specific error types
      if (error.message?.includes('offline') || error.code === 'unavailable') {
        setLastAction('ðŸ“´ Offline - will sync when online');
        // Don't set syncError for offline
      } else if (error.code === 'not-found' || error.message?.includes('does not exist')) {
        setSyncError('Database not set up. Create Firestore database in Firebase Console.');
        setLastAction('âŒ Database not configured');
      } else if (error.code === 'permission-denied') {
        setSyncError('Permission denied. Check Firestore security rules.');
        setLastAction('âŒ Permission denied');
      } else {
        setSyncError(error.message);
        setLastAction('âŒ Sync failed');
      }
    } finally {
      setSyncing(false);
    }
  }, [user, symptoms, entries, dailyNotes, stackItems, stackEntries, trackingMode, pinnedSymptoms]);

  // Load data from Firestore
  const loadFromCloud = async (uid) => {
    if (!firebaseDb) return;
    
    setSyncing(true);
    setSyncError(null);
    
    try {
      const docSnap = await firebaseDb.collection('users').doc(uid).get();
      
      if (docSnap.exists) {
        const data = docSnap.data();
        
        // Merge cloud data with local (cloud wins for conflicts)
        if (data.symptoms) setSymptoms(data.symptoms);
        if (data.entries) setEntries(data.entries);
        if (data.dailyNotes) setDailyNotes(data.dailyNotes);
        if (data.stackItems) setStackItems(data.stackItems);
        if (data.stackEntries) setStackEntries(data.stackEntries);
        if (data.trackingMode) setTrackingMode(data.trackingMode);
        if (data.pinnedSymptoms) setPinnedSymptoms(new Set(data.pinnedSymptoms));
        
        setLastSynced(data.updatedAt?.toDate() || new Date());
        setLastAction('â˜ï¸ Loaded from cloud');
      } else {
        // No cloud data yet - save local data to cloud
        setLastAction('No cloud data - will sync on save');
      }
    } catch (error) {
      console.error('Error loading from cloud:', error);
      // Handle specific error types
      if (error.message?.includes('offline') || error.code === 'unavailable') {
        setLastAction('ðŸ“´ Offline - using local data');
        // Don't set syncError for offline - it's not really an error
      } else if (error.code === 'not-found' || error.message?.includes('does not exist')) {
        setSyncError('Database not set up. Create Firestore database in Firebase Console.');
        setLastAction('âŒ Database not configured');
      } else if (error.code === 'permission-denied') {
        setSyncError('Permission denied. Check Firestore security rules.');
        setLastAction('âŒ Permission denied');
      } else {
        setSyncError(error.message);
      }
    } finally {
      setSyncing(false);
    }
  };

  // Sign in with Google
  const handleSignIn = async () => {
    if (!firebaseAuth || !googleProvider) {
      setSyncError('Firebase not loaded');
      return;
    }
    
    // Check if auth is supported
    if (!isAuthSupported()) {
      if (window.location.protocol === 'file:') {
        setSyncError('Cannot sign in from local file. Deploy to a web server.');
      } else if (isStandalone()) {
        setSyncError('Google Sign-In not supported in home screen mode. Use Safari browser instead.');
      } else {
        setSyncError('Sign-in not supported in this environment.');
      }
      return;
    }
    
    try {
      setSyncing(true);
      setSyncError(null);
      
      // Always try popup first - it's more reliable
      // Only fall back to redirect if popup is blocked
      try {
        console.log('Attempting popup sign-in...');
        const result = await firebaseAuth.signInWithPopup(googleProvider);
        console.log('Popup sign-in result:', result);
        if (result.user) {
          console.log('Signed in as:', result.user.email);
          setUser(result.user); // Explicitly set user state
          setLastAction('âœ“ Signed in as ' + result.user.email);
          // Load data from cloud
          await loadFromCloud(result.user.uid);
        }
      } catch (popupError) {
        console.log('Popup error:', popupError.code, popupError.message);
        // If popup was blocked, try redirect as fallback
        if (popupError.code === 'auth/popup-blocked') {
          console.log('Popup blocked, trying redirect...');
          setLastAction('Popup blocked, redirecting...');
          await firebaseAuth.signInWithRedirect(googleProvider);
        } else {
          throw popupError;
        }
      }
    } catch (error) {
      console.error('Sign in error:', error);
      if (error.code === 'auth/popup-closed-by-user') {
        setSyncError('Sign-in cancelled');
      } else if (error.code === 'auth/operation-not-supported-in-this-environment') {
        setSyncError('Sign-in not supported. Use Safari browser (not home screen app) or deploy to HTTPS.');
      } else if (error.code === 'auth/cancelled-popup-request') {
        // Another popup was already open, ignore
        console.log('Cancelled duplicate popup request');
      } else {
        setSyncError(error.message);
      }
      setLastAction('âŒ Sign in failed');
    } finally {
      setSyncing(false);
    }
  };

  // Email/Password sign in (works in PWA mode)
  const handleEmailSignIn = async (e) => {
    e.preventDefault();
    
    if (!firebaseAuth) {
      setSyncError('Firebase not loaded');
      return;
    }
    
    if (!authEmail || !authPassword) {
      setSyncError('Please enter email and password');
      return;
    }
    
    if (authPassword.length < 6) {
      setSyncError('Password must be at least 6 characters');
      return;
    }
    
    try {
      setSyncing(true);
      setSyncError(null);
      
      let result;
      if (isSignUp) {
        // Create new account
        result = await firebaseAuth.createUserWithEmailAndPassword(authEmail, authPassword);
        console.log('Created account:', result.user.email);
      } else {
        // Sign in to existing account
        result = await firebaseAuth.signInWithEmailAndPassword(authEmail, authPassword);
        console.log('Signed in:', result.user.email);
      }
      
      if (result.user) {
        setUser(result.user);
        setLastAction('âœ“ Signed in as ' + result.user.email);
        setAuthEmail('');
        setAuthPassword('');
        // Load data from cloud
        await loadFromCloud(result.user.uid);
      }
    } catch (error) {
      console.error('Email sign in error:', error);
      
      // Handle specific error codes with friendly messages
      if (error.code === 'auth/user-not-found') {
        setSyncError('No account with this email. Tap "Create account" to sign up.');
        setIsSignUp(true);
      } else if (error.code === 'auth/wrong-password') {
        setSyncError('Incorrect password');
      } else if (error.code === 'auth/email-already-in-use') {
        setSyncError('Account exists. Tap "Sign in" instead.');
        setIsSignUp(false);
      } else if (error.code === 'auth/invalid-email') {
        setSyncError('Invalid email address');
      } else if (error.code === 'auth/weak-password') {
        setSyncError('Password must be at least 6 characters');
      } else if (error.code === 'auth/too-many-requests') {
        setSyncError('Too many attempts. Try again later.');
      } else if (error.code === 'auth/invalid-credential') {
        setSyncError('Invalid email or password');
      } else {
        setSyncError(error.message);
      }
      setLastAction('âŒ Sign in failed');
    } finally {
      setSyncing(false);
    }
  };

  // Forgot password
  const handleForgotPassword = async () => {
    if (!firebaseAuth) {
      setSyncError('Firebase not loaded');
      return;
    }
    
    if (!authEmail) {
      setSyncError('Enter your email address first');
      return;
    }
    
    try {
      setSyncing(true);
      setSyncError(null);
      console.log('Sending password reset email to:', authEmail);
      await firebaseAuth.sendPasswordResetEmail(authEmail);
      console.log('Password reset email sent successfully');
      setLastAction('âœ“ Password reset email sent to ' + authEmail);
      // Use a success-style message
      alert('Password reset email sent to ' + authEmail + '\n\nCheck your inbox (and spam folder).');
    } catch (error) {
      console.error('Password reset error:', error.code, error.message);
      if (error.code === 'auth/user-not-found') {
        setSyncError('No account with this email. Create one first.');
      } else if (error.code === 'auth/invalid-email') {
        setSyncError('Invalid email address');
      } else if (error.code === 'auth/too-many-requests') {
        setSyncError('Too many attempts. Try again later.');
      } else if (error.code === 'auth/missing-email') {
        setSyncError('Please enter an email address');
      } else {
        setSyncError(error.code + ': ' + error.message);
      }
    } finally {
      setSyncing(false);
    }
  };

  // Sign out
  const handleSignOut = async () => {
    if (!firebaseAuth) return;
    
    try {
      await firebaseAuth.signOut();
      setLastSynced(null);
      setLastAction('Signed out');
    } catch (error) {
      console.error('Sign out error:', error);
    }
  };

  // ==========================================================================
  // HELPER FUNCTIONS
  // ==========================================================================

  // Haptic feedback for touch interactions
  const haptic = useCallback((type = 'light') => {
    if (!navigator.vibrate) return;
    switch (type) {
      case 'light':
        navigator.vibrate(10);
        break;
      case 'medium':
        navigator.vibrate(20);
        break;
      case 'heavy':
        navigator.vibrate([30, 10, 30]);
        break;
      case 'success':
        navigator.vibrate([10, 30, 10]);
        break;
      default:
        navigator.vibrate(10);
    }
  }, []);

  const formatDate = (date) => {
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    if (date.toDateString() === today.toDateString()) return 'Today';
    if (date.toDateString() === yesterday.toDateString()) return 'Yesterday';
    if (date.toDateString() === tomorrow.toDateString()) return 'Tomorrow';
    
    return date.toLocaleDateString('en-US', { 
      weekday: 'short', 
      month: 'short', 
      day: 'numeric' 
    });
  };

  const formatTableDate = (dateStr) => {
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: '2-digit'
    });
  };

  const loadSampleData = () => {
    setIsLoading(true);
    
    // Use setTimeout to allow UI to show loading state
    setTimeout(() => {
      // Load symptom sample data
      setSymptoms(defaultSymptoms);
      const sampleEntries = generateSampleData(defaultSymptoms, trackingMode);
      setEntries(sampleEntries);
      
      // Load stack sample data
      setStackItems(defaultStackItems);
      const sampleStackEntries = generateSampleStackData(defaultStackItems);
      setStackEntries(sampleStackEntries);
      
      setHasSampleData(true);
      setIsLoading(false);
      setShowSettings(false);
      setLastAction(`Loaded sample data: ${defaultSymptoms.length} symptoms, ${defaultStackItems.length} supplements`);
    }, 100);
  };

  const clearAllData = () => {
    if (!confirmClearData) {
      setConfirmClearData(true);
      return;
    }
    setEntries({});
    setStackEntries({});
    setDailyNotes({});
    setHasSampleData(false);
    setConfirmClearData(false);
    // Stay on settings page
    setLastAction('All data cleared');
  };

  // Full reset - clears EVERYTHING including symptoms and stack items
  const fullReset = () => {
    if (!confirmFullReset) {
      setConfirmFullReset(true);
      return;
    }
    
    // Clear all localStorage first
    localStorage.removeItem(STORAGE_KEY_SYMPTOMS);
    localStorage.removeItem(STORAGE_KEY_ENTRIES);
    localStorage.removeItem(STORAGE_KEY_NOTES);
    localStorage.removeItem(STORAGE_KEY_STACK_ITEMS);
    localStorage.removeItem(STORAGE_KEY_STACK_ENTRIES);
    localStorage.removeItem(STORAGE_KEY_MODE);
    localStorage.removeItem(STORAGE_KEY_APP_MODE);
    localStorage.removeItem(STORAGE_KEY_PINNED);
    
    // Force a full page reload to reset all state
    window.location.reload();
  };

  // Helper to close History and return to Settings if opened from there
  const closeHistory = () => {
    setShowHistory(false);
    if (openedFromSettings) {
      setOpenedFromSettings(false);
      setShowSettings(true);
    }
  };

  // Helper to close Export and return to Settings if opened from there
  const closeExport = () => {
    setShowExport(false);
    if (openedFromSettings) {
      setOpenedFromSettings(false);
      setShowSettings(true);
    }
  };

  // Backup all data to a JSON file (save to iCloud via Files app)
  const backupToFile = () => {
    const backup = {
      version: '3.1',
      exportedAt: new Date().toISOString(),
      symptoms,
      entries,
      dailyNotes,
      stackItems,
      stackEntries,
      trackingMode,
      pinnedSymptoms: [...pinnedSymptoms],
    };
    
    const json = JSON.stringify(backup, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `symptom-tracker-backup-${getDateKey(new Date())}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    setLastAction('Backup downloaded - save to iCloud Drive');
  };

  // Restore data from a JSON backup file
  const restoreFromFile = (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const backup = JSON.parse(e.target.result);
        
        if (backup.symptoms) setSymptoms(backup.symptoms);
        if (backup.entries) setEntries(backup.entries);
        if (backup.dailyNotes) setDailyNotes(backup.dailyNotes);
        if (backup.stackItems) setStackItems(backup.stackItems);
        if (backup.stackEntries) setStackEntries(backup.stackEntries);
        if (backup.trackingMode) setTrackingMode(backup.trackingMode);
        if (backup.pinnedSymptoms) setPinnedSymptoms(new Set(backup.pinnedSymptoms));
        
        setLastAction(`Restored backup from ${backup.exportedAt ? new Date(backup.exportedAt).toLocaleDateString() : 'file'}`);
        setShowSettings(false);
      } catch (err) {
        setLastAction('Error: Invalid backup file');
      }
    };
    reader.readAsText(file);
    // Reset the input so the same file can be selected again
    event.target.value = '';
  };

  // Hidden file input ref for restore
  const fileInputRef = useRef(null);

  // Generate sample stack entries for past 180 days
  const generateSampleStackData = (items) => {
    const entries = {};
    const today = new Date();
    
    for (let daysAgo = 0; daysAgo < 180; daysAgo++) {
      const date = new Date(today);
      date.setDate(date.getDate() - daysAgo);
      const dateKey = date.toISOString().split('T')[0];
      
      // 90% chance of taking supplements on any given day
      if (Math.random() < 0.9) {
        items.filter(item => item.active).forEach(item => {
          // 85% chance of taking each individual supplement
          if (Math.random() < 0.85) {
            const key = `${dateKey}-${item.id}`;
            // Occasionally vary the dose
            let dose = item.defaultDose;
            if (Math.random() < 0.1) {
              dose = Math.round(dose * (0.5 + Math.random()));
            }
            entries[key] = {
              date: dateKey,
              itemId: item.id,
              dose: dose,
              taken: true
            };
          }
        });
      }
    }
    
    return entries;
  };

  // ==========================================================================
  // STACK FUNCTIONS
  // ==========================================================================
  
  const toggleStackItem = (itemId) => {
    haptic('light'); // Haptic feedback on toggle
    
    const dateKey = getDateKey(selectedDate);
    const entryKey = `${dateKey}-${itemId}`;
    const item = stackItems.find(i => i.id === itemId);
    
    if (stackEntries[entryKey]) {
      // Remove entry (toggle off)
      const newEntries = { ...stackEntries };
      delete newEntries[entryKey];
      setStackEntries(newEntries);
      setLastAction(`Removed ${item?.name}`);
    } else {
      // Add entry at default dose
      setStackEntries({
        ...stackEntries,
        [entryKey]: {
          date: dateKey,
          itemId: itemId,
          dose: item?.defaultDose || 0,
          taken: true
        }
      });
      setLastAction(`Took ${item?.name}`);
    }
  };

  const updateStackDose = (itemId, newDose) => {
    const dateKey = getDateKey(selectedDate);
    const entryKey = `${dateKey}-${itemId}`;
    const item = stackItems.find(i => i.id === itemId);
    
    setStackEntries({
      ...stackEntries,
      [entryKey]: {
        date: dateKey,
        itemId: itemId,
        dose: parseFloat(newDose) || 0,
        taken: true
      }
    });
    setEditingStackItem(null);
    setLastAction(`Updated ${item?.name} to ${newDose}${item?.unit}`);
  };

  const getStackEntry = (itemId) => {
    const dateKey = getDateKey(selectedDate);
    return stackEntries[`${dateKey}-${itemId}`];
  };

  const getStackProgress = () => {
    const dateKey = getDateKey(selectedDate);
    const activeItems = stackItems.filter(i => i.active);
    const takenCount = activeItems.filter(item => 
      stackEntries[`${dateKey}-${item.id}`]
    ).length;
    return { taken: takenCount, total: activeItems.length };
  };

  const addStackItem = () => {
    if (!newStackItem.name.trim() || !newStackItem.defaultDose) return;
    
    const id = newStackItem.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    const maxOrder = Math.max(-1, ...stackItems.map(i => i.order || 0));
    
    setStackItems([...stackItems, {
      id: id,
      name: newStackItem.name.trim(),
      unit: newStackItem.unit,
      defaultDose: parseFloat(newStackItem.defaultDose),
      active: true,
      order: maxOrder + 1
    }]);
    
    setNewStackItem({ name: '', unit: 'mg', defaultDose: '' });
    setShowAddStackItem(false);
    setLastAction(`Added ${newStackItem.name}`);
  };

  const toggleStackItemActive = (itemId) => {
    setStackItems(stackItems.map(item =>
      item.id === itemId ? { ...item, active: !item.active } : item
    ));
  };

  // Copy yesterday's stack entries to today
  const copyYesterdayStack = useCallback(() => {
    const today = getDateKey(selectedDate);
    const yesterday = new Date(selectedDate);
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayKey = getDateKey(yesterday);
    
    // Get all active stack items
    const activeItems = stackItems.filter(item => item.active);
    
    if (activeItems.length === 0) {
      setLastAction('No active stack items');
      return;
    }
    
    // Start fresh - remove all of today's entries first
    const newEntries = { ...stackEntries };
    Object.keys(newEntries).forEach(key => {
      if (key.startsWith(today + '-')) {
        delete newEntries[key];
      }
    });
    
    let copiedCount = 0;
    
    // Copy yesterday's entries exactly (only checked items have entries)
    activeItems.forEach(item => {
      const yesterdayEntryKey = `${yesterdayKey}-${item.id}`;
      const todayEntryKey = `${today}-${item.id}`;
      
      const yesterdayEntry = stackEntries[yesterdayEntryKey];
      // Only copy items that were actually taken (checked) yesterday
      if (yesterdayEntry && yesterdayEntry.taken) {
        newEntries[todayEntryKey] = { 
          ...yesterdayEntry, 
          date: today 
        };
        copiedCount++;
      }
      // If unchecked yesterday, leave today empty (no entry)
    });
    
    setStackEntries(newEntries);
    haptic('success');
    if (copiedCount === 0) {
      setLastAction('Copied yesterday (nothing taken)');
    } else {
      setLastAction(`Copied ${copiedCount} items from yesterday`);
    }
  }, [selectedDate, stackItems, stackEntries, getDateKey, haptic]);

  const changeDate = useCallback((days) => {
    setSelectedDate(prevDate => {
      const newDate = new Date(prevDate);
      newDate.setDate(newDate.getDate() + days);
      
      // Don't allow navigation to future dates
      const today = new Date();
      today.setHours(23, 59, 59, 999);
      if (newDate > today) return prevDate;
      
      return newDate;
    });
    setLastAction('');
  }, []);

  const selectDate = useCallback((date) => {
    // Don't allow selection of future dates
    const today = new Date();
    today.setHours(23, 59, 59, 999);
    if (date > today) return;
    
    setSelectedDate(date);
    setShowCalendar(false);
    setLastAction('');
  }, []);
  
  // Quick log a symptom at specific severity (tap-to-log)
  const quickLog = useCallback((symptomId, severity, timeOverride = null) => {
    const dateKey = getDateKey(selectedDate);
    const timeId = timeOverride || timePeriods[0].id;
    const key = `${dateKey}-${symptomId}-${timeId}`;
    
    // Mark that user just logged (for completion detection)
    markJustLogged();
    
    setEntries(prev => ({
      ...prev,
      [key]: { time: timeId, severity, date: dateKey, symptomId }
    }));
    
    const symptom = symptoms.find(s => s.id === symptomId);
    const period = timePeriods.find(p => p.id === timeId);
    haptic('light');
    setQuickLogSymptom(null);
    // Keep quickLogTime sticky - don't reset it
    setLastAction(`${symptom?.name}: ${severity} (${period?.label || timeId})`);
  }, [selectedDate, timePeriods, symptoms, getDateKey, haptic, markJustLogged]);

  // Log all active symptoms at severity 0 ("Good Day" feature)
  const logGoodDay = useCallback(() => {
    const dateKey = getDateKey(selectedDate);
    const timeId = timePeriods[0].id;
    const activeSymptomsList = symptoms.filter(s => s.active);
    
    // Mark that user just logged (for completion detection)
    markJustLogged();
    
    const newEntries = { ...entries };
    activeSymptomsList.forEach(symptom => {
      const key = `${dateKey}-${symptom.id}-${timeId}`;
      newEntries[key] = { time: timeId, severity: 0, date: dateKey, symptomId: symptom.id };
    });
    
    setEntries(newEntries);
    haptic('success');
    setLastAction(`â˜€ï¸ Good day! Logged ${activeSymptomsList.length} symptoms at 0`);
  }, [selectedDate, timePeriods, symptoms, entries, getDateKey, haptic, markJustLogged]);

  // Toggle pin status for a symptom
  const togglePin = useCallback((symptomId) => {
    setPinnedSymptoms(prev => {
      const newPinned = new Set(prev);
      if (newPinned.has(symptomId)) {
        newPinned.delete(symptomId);
        setLastAction('Unpinned');
      } else {
        newPinned.add(symptomId);
        haptic('light');
        setLastAction('Pinned to top');
      }
      return newPinned;
    });
  }, [haptic]);

  // Scroll to notes and focus
  const scrollToNotes = useCallback(() => {
    if (notesTextareaRef.current) {
      // Focus first to trigger keyboard on mobile
      notesTextareaRef.current.focus();
      // Then scroll into view
      setTimeout(() => {
        notesTextareaRef.current?.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }, 100);
    }
  }, []);

  // Check if we can navigate forward
  const canGoForward = useMemo(() => {
    const tomorrow = new Date(selectedDate);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const today = new Date();
    today.setHours(23, 59, 59, 999);
    return tomorrow <= today;
  }, [selectedDate]);

  // Swipe handlers for date navigation
  const handleSwipeStart = useCallback((e) => {
    const touch = e.touches ? e.touches[0] : e;
    swipeStartRef.current = { 
      x: touch.clientX, 
      y: touch.clientY, 
      time: Date.now() 
    };
  }, []);

  const handleSwipeEnd = useCallback((e) => {
    const touch = e.changedTouches ? e.changedTouches[0] : e;
    const deltaX = touch.clientX - swipeStartRef.current.x;
    const deltaY = touch.clientY - swipeStartRef.current.y;
    const deltaTime = Date.now() - swipeStartRef.current.time;
    
    // Check if it's a valid horizontal swipe
    if (deltaTime < SWIPE_TIME_LIMIT && 
        Math.abs(deltaX) > SWIPE_THRESHOLD && 
        Math.abs(deltaX) > Math.abs(deltaY) * 1.5) {
      haptic('light'); // Haptic feedback on date swipe
      if (deltaX > 0) {
        // Swipe right = previous day
        changeDate(-1);
      } else {
        // Swipe left = next day
        changeDate(1);
      }
    }
  }, [changeDate, haptic]);

  // ==========================================================================
  // TOUCH & DRAG HANDLERS
  // ==========================================================================

  const enterEditMode = (symptomId, clientX, clientY) => {
    haptic('medium'); // Haptic feedback when entering edit mode
    
    const screenHeight = window.innerHeight;
    const relativeY = clientY / screenHeight;
    let initialSeverity;
    if (relativeY < 0.25) {
      initialSeverity = 5;
    } else if (relativeY > 0.75) {
      initialSeverity = 0;
    } else {
      initialSeverity = 2;
    }
    
    // Calculate time index based on mode
    let clampedTimeIndex = 0;
    if (trackingMode !== 'simple') {
      const screenWidth = window.innerWidth;
      const numPeriods = timePeriods.length;
      const timeIndex = Math.floor((clientX / screenWidth) * numPeriods);
      clampedTimeIndex = Math.max(0, Math.min(numPeriods - 1, timeIndex));
    }
    
    setActiveSymptom(symptomId);
    setDragPosition({ x: clampedTimeIndex, y: initialSeverity });
    isDraggingRef.current = true;
    setIsDragging(true);
    pendingSymptomRef.current = null;
  };

  const handleTouchStart = (e, symptomId) => {
    const touch = e.touches[0];
    startPosRef.current = { x: touch.clientX, y: touch.clientY };
    setFingerPosition({ x: touch.clientX, y: touch.clientY });
    pendingSymptomRef.current = symptomId;
    
    holdTimerRef.current = setTimeout(() => {
      if (pendingSymptomRef.current === symptomId) {
        enterEditMode(symptomId, touch.clientX, touch.clientY);
      }
    }, HOLD_DELAY);
  };

  const handleMouseDown = (e, symptomId) => {
    e.preventDefault();
    startPosRef.current = { x: e.clientX, y: e.clientY };
    setFingerPosition({ x: e.clientX, y: e.clientY });
    pendingSymptomRef.current = symptomId;
    
    holdTimerRef.current = setTimeout(() => {
      if (pendingSymptomRef.current === symptomId) {
        enterEditMode(symptomId, e.clientX, e.clientY);
      }
    }, HOLD_DELAY);
  };

  const handleMove = (clientX, clientY) => {
    if (pendingSymptomRef.current && !isDragging) {
      const deltaX = Math.abs(clientX - startPosRef.current.x);
      const deltaY = Math.abs(clientY - startPosRef.current.y);
      
      if (deltaX > 10 || deltaY > 10) {
        if (holdTimerRef.current) {
          clearTimeout(holdTimerRef.current);
          holdTimerRef.current = null;
        }
        pendingSymptomRef.current = null;
      }
      return;
    }
    
    if (!isDragging || !activeSymptom) return;
    
    setFingerPosition({ x: clientX, y: clientY });
    
    // Calculate time index based on mode
    let timeIndex = 0;
    if (trackingMode !== 'simple') {
      const screenWidth = window.innerWidth;
      const numPeriods = timePeriods.length;
      timeIndex = Math.floor((clientX / screenWidth) * numPeriods);
      timeIndex = Math.max(0, Math.min(numPeriods - 1, timeIndex));
    }
    
    const deltaY = startPosRef.current.y - clientY;
    let severityDelta = Math.round(deltaY / DRAG_SENSITIVITY);
    
    const screenHeight = window.innerHeight;
    const relativeStartY = startPosRef.current.y / screenHeight;
    let baseSeverity;
    if (relativeStartY < 0.25) {
      baseSeverity = 5;
    } else if (relativeStartY > 0.75) {
      baseSeverity = 0;
    } else {
      baseSeverity = 2;
    }
    
    let severityIndex = baseSeverity + severityDelta;
    severityIndex = Math.max(0, Math.min(5, severityIndex));
    
    setDragPosition({ x: timeIndex, y: severityIndex });
  };

  const handleTouchMove = (e) => {
    if (isDragging) {
      e.preventDefault();
    }
    const touch = e.touches[0];
    handleMove(touch.clientX, touch.clientY);
  };

  const handleMouseMove = (e) => {
    handleMove(e.clientX, e.clientY);
  };

  const handleEnd = () => {
    if (holdTimerRef.current) {
      clearTimeout(holdTimerRef.current);
      holdTimerRef.current = null;
    }
    pendingSymptomRef.current = null;
    
    if (isDragging && activeSymptom) {
      haptic('success'); // Haptic feedback when saving entry
      
      const dateKey = getDateKey(selectedDate);
      const timeId = timePeriods[dragPosition.x].id;
      const severity = dragPosition.y;
      const key = `${dateKey}-${activeSymptom}-${timeId}`;
      
      setEntries({
        ...entries,
        [key]: { time: timeId, severity, date: dateKey, symptomId: activeSymptom }
      });
      
      const symptom = symptoms.find(s => s.id === activeSymptom);
      setLastAction(`${symptom?.name}: ${timePeriods[dragPosition.x].label}, ${severity}`);
    }
    isDraggingRef.current = false;
    setIsDragging(false);
    setActiveSymptom(null);
  };

  const getSymptomEntries = (symptomId) => {
    const dateKey = getDateKey(selectedDate);
    const timeOrder = { night: 0, morning: 1, allday: 2, midday: 3, evening: 4, daily: 2 };
    return Object.entries(entries)
      .filter(([key]) => key.startsWith(`${dateKey}-${symptomId}`))
      .map(([key, value]) => value)
      .sort((a, b) => (timeOrder[a.time] || 0) - (timeOrder[b.time] || 0));
  };

  // Get the most recent entry for a symptom (regardless of AM/PM)
  const getMostRecentEntry = (symptomId) => {
    const allEntries = Object.entries(entries)
      .filter(([key]) => key.includes(`-${symptomId}-`))
      .map(([key, value]) => ({ key, ...value }))
      .sort((a, b) => {
        // Sort by date descending, then by time
        const dateCompare = b.date.localeCompare(a.date);
        if (dateCompare !== 0) return dateCompare;
        // Same date - prefer evening over morning
        const timeOrder = { evening: 2, daily: 1, morning: 0 };
        return (timeOrder[b.time] || 0) - (timeOrder[a.time] || 0);
      });
    
    // Return the most recent entry that's not from today
    const todayKey = getDateKey(selectedDate);
    for (const entry of allEntries) {
      if (entry.date !== todayKey) {
        return entry;
      }
    }
    return null;
  };

  const parseBulkSymptoms = (input) => {
    return input
      .split(/[,\t\n\r;]+/)
      .map(s => s.trim())
      .filter(s => s.length > 0);
  };

  const addBulkSymptoms = () => {
    const names = parseBulkSymptoms(bulkSymptomInput);
    if (names.length === 0) return;

    const newSymptoms = [...symptoms];
    let addedCount = 0;

    names.forEach(name => {
      const existing = newSymptoms.find(s => s.name.toLowerCase() === name.toLowerCase());
      if (existing) {
        if (!existing.active) {
          existing.active = true;
          addedCount++;
        }
      } else {
        const id = name.toLowerCase().replace(/\s+/g, '-') + '-' + Date.now() + Math.random();
        newSymptoms.push({ id, name, active: true });
        addedCount++;
      }
    });

    setSymptoms(newSymptoms);
    setBulkSymptomInput('');
    setLastAction(`Added ${addedCount} symptom${addedCount !== 1 ? 's' : ''}`);
  };

  const removeSymptom = (symptomId) => {
    setSymptoms(symptoms.map(s => 
      s.id === symptomId ? { ...s, active: false } : s
    ));
    setLastAction('Symptom hidden (history preserved)');
  };

  const reactivateSymptom = (symptomId) => {
    setSymptoms(symptoms.map(s => 
      s.id === symptomId ? { ...s, active: true } : s
    ));
    setLastAction('Symptom restored');
  };

  const startEditingSymptom = (symptom) => {
    setEditingSymptomId(symptom.id);
    setEditingSymptomName(symptom.name);
  };

  const saveSymptomName = () => {
    if (editingSymptomName.trim() && editingSymptomId) {
      setSymptoms(symptoms.map(s => 
        s.id === editingSymptomId ? { ...s, name: editingSymptomName.trim() } : s
      ));
      setLastAction('Symptom renamed');
    }
    setEditingSymptomId(null);
    setEditingSymptomName('');
  };

  const cancelEditingSymptom = () => {
    setEditingSymptomId(null);
    setEditingSymptomName('');
  };

  // Stack item editing functions
  const startEditingStackItem = (item) => {
    setEditingStackItemId(item.id);
    setEditingStackItemData({ name: item.name, defaultDose: item.defaultDose, unit: item.unit });
  };

  const saveStackItemEdit = () => {
    if (editingStackItemData.name.trim() && editingStackItemId) {
      setStackItems(stackItems.map(item => 
        item.id === editingStackItemId 
          ? { ...item, name: editingStackItemData.name.trim(), defaultDose: editingStackItemData.defaultDose, unit: editingStackItemData.unit } 
          : item
      ));
    }
    setEditingStackItemId(null);
    setEditingStackItemData({ name: '', defaultDose: '', unit: 'mg' });
  };

  const cancelEditingStackItem = () => {
    setEditingStackItemId(null);
    setEditingStackItemData({ name: '', defaultDose: '', unit: 'mg' });
  };

  const deleteStackItem = (itemId) => {
    setStackItems(stackItems.filter(item => item.id !== itemId));
  };

  // Drag-to-reorder handlers (touch-based with animation)
  const handleReorderStart = (e, item, type, index, itemsList) => {
    e.stopPropagation();
    const touch = e.touches ? e.touches[0] : e;
    dragStartY.current = touch.clientY;
    dragItemHeight.current = e.currentTarget.closest('[data-reorder-item]')?.offsetHeight || 52;
    setDraggedItem({ id: item.id, type, startIndex: index, itemsList });
    setDragOverIndex(index);
    setDragY(0);
    haptic('medium');
  };

  const handleReorderMove = (e) => {
    if (!draggedItem) return;
    e.preventDefault();
    
    const touch = e.touches ? e.touches[0] : e;
    const deltaY = touch.clientY - dragStartY.current;
    setDragY(deltaY);
    
    // Calculate which index we're hovering over
    const indexOffset = Math.round(deltaY / dragItemHeight.current);
    const newIndex = Math.max(0, Math.min(
      draggedItem.itemsList.length - 1, 
      draggedItem.startIndex + indexOffset
    ));
    
    if (newIndex !== dragOverIndex) {
      setDragOverIndex(newIndex);
      haptic('light');
    }
  };

  const handleReorderEnd = () => {
    if (!draggedItem || dragOverIndex === null) {
      setDraggedItem(null);
      setDragOverIndex(null);
      setDragY(0);
      return;
    }
    
    const { type, startIndex, itemsList } = draggedItem;
    
    if (startIndex !== dragOverIndex) {
      if (type === 'symptom') {
        // Reorder symptoms
        const newSymptoms = [...symptoms];
        const activeIds = itemsList.map(s => s.id);
        const [movedId] = activeIds.splice(startIndex, 1);
        activeIds.splice(dragOverIndex, 0, movedId);
        
        activeIds.forEach((id, idx) => {
          const symptomIdx = newSymptoms.findIndex(s => s.id === id);
          if (symptomIdx !== -1) {
            newSymptoms[symptomIdx] = { ...newSymptoms[symptomIdx], order: idx };
          }
        });
        setSymptoms(newSymptoms);
      } else if (type === 'stack') {
        // Reorder stack items
        const newStackItems = [...stackItems];
        const activeIds = itemsList.map(s => s.id);
        const [movedId] = activeIds.splice(startIndex, 1);
        activeIds.splice(dragOverIndex, 0, movedId);
        
        activeIds.forEach((id, idx) => {
          const itemIdx = newStackItems.findIndex(s => s.id === id);
          if (itemIdx !== -1) {
            newStackItems[itemIdx] = { ...newStackItems[itemIdx], order: idx };
          }
        });
        setStackItems(newStackItems);
      }
      haptic('medium');
    }
    
    setDraggedItem(null);
    setDragOverIndex(null);
    setDragY(0);
  };

  // Calculate transform for reorder animation
  const getReorderTransform = (index, type) => {
    if (!draggedItem || draggedItem.type !== type) return {};
    
    const { startIndex } = draggedItem;
    const height = dragItemHeight.current;
    
    if (index === startIndex) {
      // This is the dragged item - follow the finger
      return {
        transform: `translateY(${dragY}px)`,
        zIndex: 100,
        boxShadow: '0 8px 32px rgba(0,0,0,0.4)',
        transition: 'box-shadow 0.2s ease',
      };
    }
    
    // Other items shift to make room
    if (dragOverIndex !== null && dragOverIndex !== startIndex) {
      if (startIndex < dragOverIndex) {
        // Dragging down - items between start and target shift up
        if (index > startIndex && index <= dragOverIndex) {
          return {
            transform: `translateY(-${height}px)`,
            transition: 'transform 0.2s ease',
          };
        }
      } else {
        // Dragging up - items between target and start shift down
        if (index >= dragOverIndex && index < startIndex) {
          return {
            transform: `translateY(${height}px)`,
            transition: 'transform 0.2s ease',
          };
        }
      }
    }
    
    return {
      transform: 'translateY(0)',
      transition: 'transform 0.2s ease',
    };
  };

  // Swipe-to-delete handlers
  const handleItemSwipeStart = (e, itemId) => {
    const touch = e.touches ? e.touches[0] : e;
    swipeStartRef.current = { x: touch.clientX, y: touch.clientY, id: itemId };
  };

  const handleItemSwipeMove = (e, itemId) => {
    if (swipeStartRef.current.id !== itemId) return;
    
    const touch = e.touches ? e.touches[0] : e;
    const deltaX = touch.clientX - swipeStartRef.current.x;
    const deltaY = Math.abs(touch.clientY - swipeStartRef.current.y);
    
    // Only track horizontal swipes (not vertical scrolling)
    if (deltaY > 30) {
      swipeStartRef.current = { x: 0, y: 0, id: null };
      setSwipeOffsets(prev => ({ ...prev, [itemId]: 0 }));
      return;
    }
    
    // Only allow left swipes (negative deltaX), cap at -100
    if (deltaX < 0) {
      setSwipeOffsets(prev => ({ ...prev, [itemId]: Math.max(deltaX, -100) }));
    }
  };

  const handleItemSwipeEnd = (itemId, onDelete) => {
    const offset = swipeOffsets[itemId] || 0;
    
    if (offset < -60) {
      // Swiped far enough - trigger delete
      onDelete();
    }
    
    // Reset swipe
    setSwipeOffsets(prev => ({ ...prev, [itemId]: 0 }));
    swipeStartRef.current = { x: 0, y: 0, id: null };
  };

  const clearEntry = (symptomId, timeId) => {
    const dateKey = getDateKey(selectedDate);
    const key = `${dateKey}-${symptomId}-${timeId}`;
    const deletedEntry = entries[key];
    
    if (deletedEntry) {
      // Save for undo
      setLastDeletedEntry({ key, entry: deletedEntry });
      
      const newEntries = { ...entries };
      delete newEntries[key];
      setEntries(newEntries);
      setLastAction('Entry cleared - tap to undo');
    }
  };

  const undoDelete = useCallback(() => {
    if (lastDeletedEntry) {
      setEntries(prev => ({
        ...prev,
        [lastDeletedEntry.key]: lastDeletedEntry.entry
      }));
      setLastAction('Entry restored');
      setLastDeletedEntry(null);
    }
  }, [lastDeletedEntry]);

  const getCalendarDays = () => {
    const year = calendarMonth.getFullYear();
    const month = calendarMonth.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startingDay = firstDay.getDay();
    
    const days = [];
    for (let i = 0; i < startingDay; i++) {
      days.push(null);
    }
    for (let i = 1; i <= daysInMonth; i++) {
      days.push(new Date(year, month, i));
    }
    return days;
  };

  const sortedHistory = useMemo(() => {
    const history = Object.entries(entries).map(([key, value]) => ({
      ...value,
      key,
      symptomName: symptoms.find(s => s.id === value.symptomId)?.name || value.symptomId,
      timePeriodLabel: timePeriods.find(t => t.id === value.time)?.label || value.time,
    }));

    return history.sort((a, b) => {
      let comparison = 0;
      
      switch (historySort.column) {
        case 'date':
          comparison = a.date.localeCompare(b.date);
          break;
        case 'symptom':
          comparison = a.symptomName.localeCompare(b.symptomName);
          break;
        case 'time':
          const timeOrder = { night: 0, morning: 1, allday: 2, midday: 3, evening: 4 };
          comparison = (timeOrder[a.time] || 0) - (timeOrder[b.time] || 0);
          break;
        case 'severity':
          comparison = a.severity - b.severity;
          break;
        default:
          comparison = 0;
      }
      
      return historySort.direction === 'asc' ? comparison : -comparison;
    });
  }, [entries, symptoms, timePeriods, historySort]);

  const toggleSort = (column) => {
    if (historySort.column === column) {
      setHistorySort({
        column,
        direction: historySort.direction === 'asc' ? 'desc' : 'asc'
      });
    } else {
      setHistorySort({ column, direction: 'desc' });
    }
  };

  const getSortIndicator = (column) => {
    if (historySort.column !== column) return '';
    return historySort.direction === 'asc' ? ' â†‘' : ' â†“';
  };

  // ==========================================================================
  // INSIGHTS & DATA ANALYSIS
  // ==========================================================================

  const getInsights = (windowDays = 60) => {
    const today = new Date();
    const entryList = Object.values(entries);
    
    // Need at least some data for meaningful insights
    const oldestEntry = entryList.reduce((min, e) => e.date < min ? e.date : min, entryList[0]?.date || '');
    const daysOfData = oldestEntry ? Math.floor((today - new Date(oldestEntry)) / (1000 * 60 * 60 * 24)) : 0;
    
    const minDaysNeeded = Math.floor(windowDays * 1.5);
    if (entryList.length < 20 || daysOfData < minDaysNeeded) {
      return { hasEnoughData: false, daysOfData, entriesCount: entryList.length, minDaysNeeded };
    }
    
    // Group entries by symptom
    const bySymptom = {};
    entryList.forEach(entry => {
      if (!bySymptom[entry.symptomId]) bySymptom[entry.symptomId] = [];
      bySymptom[entry.symptomId].push(entry);
    });
    
    const insights = [];
    
    // Calculate trends: last windowDays vs prior windowDays
    Object.entries(bySymptom).forEach(([symptomId, symptomEntries]) => {
      const symptom = symptoms.find(s => s.id === symptomId);
      if (!symptom) return;
      
      const recentEntries = symptomEntries.filter(e => {
        const daysAgo = Math.floor((today - new Date(e.date)) / (1000 * 60 * 60 * 24));
        return daysAgo <= windowDays;
      });
      const earlierEntries = symptomEntries.filter(e => {
        const daysAgo = Math.floor((today - new Date(e.date)) / (1000 * 60 * 60 * 24));
        return daysAgo > windowDays && daysAgo <= windowDays * 2;
      });
      
      // Need enough data in both periods
      if (recentEntries.length < 3 || earlierEntries.length < 3) return;
      
      const recentAvg = recentEntries.reduce((sum, e) => sum + e.severity, 0) / recentEntries.length;
      const earlierAvg = earlierEntries.reduce((sum, e) => sum + e.severity, 0) / earlierEntries.length;
      
      // Only show if there's meaningful change (>20%)
      if (earlierAvg === 0) return;
      const percentChange = Math.round(((recentAvg - earlierAvg) / earlierAvg) * 100);
      
      if (Math.abs(percentChange) >= 20) {
        insights.push({
          symptomId,
          name: symptom.name,
          percentChange,
          direction: percentChange < 0 ? 'improving' : 'worsening',
          recentAvg: recentAvg.toFixed(1),
          earlierAvg: earlierAvg.toFixed(1),
        });
      }
    });
    
    // Sort by absolute percent change (biggest changes first)
    insights.sort((a, b) => Math.abs(b.percentChange) - Math.abs(a.percentChange));
    
    // Find most common symptom cluster (symptoms appearing together)
    const dateGroups = {};
    entryList.forEach(entry => {
      if (!dateGroups[entry.date]) dateGroups[entry.date] = new Set();
      dateGroups[entry.date].add(entry.symptomId);
    });
    
    const coOccurrence = {};
    Object.values(dateGroups).forEach(symptomSet => {
      const symptomArray = Array.from(symptomSet);
      for (let i = 0; i < symptomArray.length; i++) {
        for (let j = i + 1; j < symptomArray.length; j++) {
          const key = [symptomArray[i], symptomArray[j]].sort().join('|');
          coOccurrence[key] = (coOccurrence[key] || 0) + 1;
        }
      }
    });
    
    // Only show cluster if it appears frequently (>30% of days)
    const totalDays = Object.keys(dateGroups).length;
    const topCluster = Object.entries(coOccurrence)
      .map(([pair, count]) => {
        const [id1, id2] = pair.split('|');
        const name1 = symptoms.find(s => s.id === id1)?.name || id1;
        const name2 = symptoms.find(s => s.id === id2)?.name || id2;
        return { names: [name1, name2], count, percent: Math.round((count / totalDays) * 100) };
      })
      .filter(c => c.percent >= 30)
      .sort((a, b) => b.count - a.count)[0] || null;
    
    // Generate simplified AI prompt
    const aiPrompt = generateAIPrompt(insights, topCluster, daysOfData, windowDays);
    
    return {
      hasEnoughData: true,
      insights: insights.slice(0, 5), // Top 5 only
      topCluster,
      daysOfData,
      entriesCount: entryList.length,
      aiPrompt,
      windowDays,
    };
  };

  const generateAIPrompt = (insights, topCluster, daysOfData, windowDays) => {
    let prompt = `Analyze my symptom tracking data. Be cautious and avoid prescriptive medical advice.\n\n`;
    
    if (insights.length > 0) {
      prompt += `Significant changes (last ${windowDays} days vs prior ${windowDays} days):\n`;
      insights.forEach(i => {
        prompt += `â€¢ ${i.name}: ${i.percentChange > 0 ? '+' : ''}${i.percentChange}% (${i.direction})\n`;
      });
    }
    
    if (topCluster) {
      prompt += `\nFrequent co-occurrence (${topCluster.percent}% of days):\n`;
      prompt += `â€¢ "${topCluster.names[0]}" often appears with "${topCluster.names[1]}"\n`;
    }
    
    // Add last 60 days of raw data
    const sixtyDaysAgo = new Date();
    sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 60);
    
    const recentEntries = Object.values(entries)
      .filter(e => new Date(e.date) >= sixtyDaysAgo)
      .sort((a, b) => b.date.localeCompare(a.date));
    
    if (recentEntries.length > 0) {
      prompt += `\n\n--- RAW DATA (Last 60 days) ---\n`;
      prompt += `Date,Symptom,Time,Severity\n`;
      recentEntries.forEach(e => {
        const symptomName = symptoms.find(s => s.id === e.symptomId)?.name || e.symptomId;
        const timePeriod = timePeriods.find(t => t.id === e.time)?.label || e.time;
        prompt += `${e.date},${symptomName},${timePeriod},${e.severity}\n`;
      });
    }
    
    // Add stack data for last 60 days
    const recentStackEntries = Object.values(stackEntries)
      .filter(e => {
        const entryDate = new Date(e.date);
        return entryDate >= sixtyDaysAgo;
      })
      .sort((a, b) => b.date.localeCompare(a.date));
    
    if (recentStackEntries.length > 0) {
      prompt += `\n--- SUPPLEMENT DATA (Last 60 days) ---\n`;
      prompt += `Date,Supplement,Dose,Taken\n`;
      recentStackEntries.forEach(e => {
        const item = stackItems.find(i => i.id === e.itemId);
        if (item) {
          prompt += `${e.date},${item.name},${e.dose}${item.unit},${e.taken ? 'yes' : 'no'}\n`;
        }
      });
    }
    
    prompt += `\n--- END DATA ---\n\nPlease identify potential patterns, correlations between symptoms and supplements, and what might be worth discussing with a healthcare provider.`;
    
    return prompt;
  };

  // Generate AI-ready data export for a specific number of days
  const generateAIDataExport = (days) => {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    
    let prompt = `Analyze my health tracking data from the last ${days} days. Be cautious and avoid prescriptive medical advice.\n\n`;
    
    // Symptom data
    const recentEntries = Object.values(entries)
      .filter(e => new Date(e.date) >= cutoffDate)
      .sort((a, b) => b.date.localeCompare(a.date));
    
    if (recentEntries.length > 0) {
      prompt += `--- SYMPTOM DATA (Last ${days} days) ---\n`;
      prompt += `Date,Symptom,Time,Severity (0-5)\n`;
      recentEntries.forEach(e => {
        const symptomName = symptoms.find(s => s.id === e.symptomId)?.name || e.symptomId;
        const timePeriod = timePeriods.find(t => t.id === e.time)?.label || e.time;
        prompt += `${e.date},${symptomName},${timePeriod},${e.severity}\n`;
      });
    } else {
      prompt += `No symptom data in the last ${days} days.\n`;
    }
    
    // Supplement data
    const recentStackEntries = Object.values(stackEntries)
      .filter(e => new Date(e.date) >= cutoffDate)
      .sort((a, b) => b.date.localeCompare(a.date));
    
    if (recentStackEntries.length > 0) {
      prompt += `\n--- SUPPLEMENT DATA (Last ${days} days) ---\n`;
      prompt += `Date,Supplement,Dose,Taken\n`;
      recentStackEntries.forEach(e => {
        const item = stackItems.find(i => i.id === e.itemId);
        if (item) {
          prompt += `${e.date},${item.name},${e.dose}${item.unit},${e.taken ? 'yes' : 'no'}\n`;
        }
      });
    } else {
      prompt += `\nNo supplement data in the last ${days} days.\n`;
    }
    
    prompt += `\n--- END DATA ---\n\nPlease identify potential patterns, correlations between symptoms and supplements, and what might be worth discussing with a healthcare provider.`;
    
    return prompt;
  };

  const copyAIData = (days) => {
    const data = generateAIDataExport(days);
    navigator.clipboard.writeText(data);
    closeExport();
    setLastAction(`Copied ${days} days for AI analysis`);
  };

  // Copy today's symptoms and stack for AI
  const copyTodayForAI = () => {
    const dateKey = getDateKey(selectedDate);
    let prompt = `Here's my health data for ${selectedDate.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}:\n\n`;
    
    // Get today's symptom entries
    const todayEntries = Object.values(entries).filter(e => e.date === dateKey);
    if (todayEntries.length > 0) {
      prompt += `**Symptoms:**\n`;
      todayEntries.forEach(e => {
        const symptomName = symptoms.find(s => s.id === e.symptomId)?.name || e.symptomId;
        const timePeriod = timePeriods.find(t => t.id === e.time)?.label || e.time;
        prompt += `- ${symptomName} (${timePeriod}): ${e.severity}/5 - ${severityLabels[e.severity]}\n`;
      });
    } else {
      prompt += `**Symptoms:** None recorded\n`;
    }
    
    // Get today's stack entries
    const todayStackEntries = Object.values(stackEntries).filter(e => e.date === dateKey);
    if (todayStackEntries.length > 0) {
      prompt += `\n**Supplements taken:**\n`;
      todayStackEntries.filter(e => e.taken).forEach(e => {
        const item = stackItems.find(i => i.id === e.itemId);
        if (item) {
          const multiplier = e.multiplier && e.multiplier > 1 ? ` (${e.multiplier}x)` : '';
          prompt += `- ${item.name}: ${e.dose}${item.unit}${multiplier}\n`;
        }
      });
      const skipped = todayStackEntries.filter(e => !e.taken);
      if (skipped.length > 0) {
        prompt += `\n**Supplements skipped:**\n`;
        skipped.forEach(e => {
          const item = stackItems.find(i => i.id === e.itemId);
          if (item) prompt += `- ${item.name}\n`;
        });
      }
    }
    
    // Get today's notes
    const todayNotes = dailyNotes[dateKey];
    if (todayNotes) {
      prompt += `\n**Notes:**\n${todayNotes}\n`;
    }
    
    prompt += `\nPlease analyze this data and provide any observations or suggestions.`;
    
    navigator.clipboard.writeText(prompt);
    setLastAction('Copied today\'s data for AI');
  };

  const exportCSV = (days) => {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    
    const rows = [['Date', 'Symptom', 'Time Period', 'Severity', 'Severity Label']];
    
    Object.entries(entries).forEach(([key, entry]) => {
      const entryDate = new Date(entry.date);
      if (entryDate >= startDate && entryDate <= endDate) {
        const symptomName = symptoms.find(s => s.id === entry.symptomId)?.name || entry.symptomId;
        const timePeriod = timePeriods.find(t => t.id === entry.time)?.label || entry.time;
        rows.push([entry.date, symptomName, timePeriod, entry.severity, severityLabels[entry.severity]]);
      }
    });
    
    rows.sort((a, b) => {
      if (a[0] === 'Date') return -1;
      if (b[0] === 'Date') return 1;
      return b[0].localeCompare(a[0]);
    });
    
    const csv = rows.map(row => row.join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `symptoms-${days}days-${getDateKey(new Date())}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    closeExport();
    setLastAction(`Exported ${rows.length - 1} entries`);
  };

  const currentSymptomName = useMemo(() => 
    symptoms.find(s => s.id === activeSymptom)?.name || '',
    [symptoms, activeSymptom]
  );

  const tableHeaderStyle = {
    padding: '12px 8px',
    textAlign: 'left',
    color: '#94a3b8',
    fontSize: '11px',
    fontWeight: '600',
    textTransform: 'uppercase',
    letterSpacing: '0.5px',
    cursor: 'pointer',
    borderBottom: '2px solid rgba(99, 102, 241, 0.3)',
    whiteSpace: 'nowrap',
    userSelect: 'none',
  };

  const tableCellStyle = {
    padding: '10px 8px',
    fontSize: '13px',
    borderBottom: '1px solid rgba(99, 102, 241, 0.1)',
  };

  // ==========================================================================
  // RENDER
  // ==========================================================================

  return (
    <div 
      ref={containerRef}
      onMouseMove={handleMouseMove}
      onMouseUp={handleEnd}
      onMouseLeave={handleEnd}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleEnd}
      style={{
        height: '100dvh',
        minHeight: '100vh',
        background: 'linear-gradient(180deg, #0c0a1d 0%, #1a1333 100%)',
        fontFamily: "'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif",
        userSelect: 'none',
        WebkitUserSelect: 'none',
        WebkitTouchCallout: 'none',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden',
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
      }}
    >
      {/* COMPLETION CELEBRATION */}
      {showCompletion && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: 'rgba(12, 10, 29, 0.95)',
          zIndex: 1100,
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
          gap: '16px',
          animation: 'fadeIn 0.3s ease',
        }}>
          <div style={{
            fontSize: '64px',
            animation: 'popIn 0.4s ease',
          }}>
            âœ“
          </div>
          <div style={{
            color: '#10b981',
            fontSize: '24px',
            fontWeight: '700',
            textAlign: 'center',
          }}>
            All done!
          </div>
          <div style={{
            color: '#94a3b8',
            fontSize: '14px',
          }}>
            {trackingMode === 'ampm' 
              ? `${quickLogTime === 'morning' ? 'Morning' : 'Evening'} symptoms logged`
              : 'All symptoms logged for today'
            }
          </div>
        </div>
      )}

      {/* RAPID ENTRY MODE - Full screen overlay */}
      {rapidEntryMode && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: 'linear-gradient(180deg, #0c0a1d 0%, #1a1333 100%)',
          zIndex: 1000,
          display: 'flex',
          flexDirection: 'column',
          padding: '20px',
        }}>
          {/* Header */}
          <div style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: '20px',
          }}>
            <div style={{ color: '#34d399', fontSize: '14px', display: 'flex', alignItems: 'center', gap: '6px' }}>
              <svg width="16" height="16" viewBox="0 0 24 24" fill="#34d399" stroke="none">
                <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
              </svg>
              Rapid Entry
            </div>
            <button
              onClick={() => {
                setRapidEntryMode(false);
                setRapidEntryConfirm(false);
              }}
              style={{
                background: 'rgba(239, 68, 68, 0.15)',
                border: '1px solid rgba(239, 68, 68, 0.3)',
                borderRadius: '3px',
                padding: '8px 16px',
                color: '#f87171',
                fontSize: '14px',
                fontWeight: '600',
                cursor: 'pointer',
              }}
            >
              âœ• Close
            </button>
          </div>
          
          {/* Confirmation dialog when all complete */}
          {rapidEntryConfirm ? (
            <div style={{
              flex: 1,
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              gap: '24px',
            }}>
              <div style={{ color: '#10b981', fontSize: '48px' }}>âœ“</div>
              <div style={{ color: '#f8fafc', fontSize: '20px', fontWeight: '600', textAlign: 'center' }}>
                All {trackingMode === 'ampm' ? (quickLogTime === 'morning' ? 'AM' : 'PM') : ''} symptoms logged
              </div>
              
              {/* Check if opposite period has incomplete symptoms */}
              {(() => {
                if (trackingMode !== 'ampm') return null;
                
                const dateKey = selectedDate.toISOString().split('T')[0];
                const currentPeriod = quickLogTime || getCurrentTimePeriod();
                const oppositePeriod = currentPeriod === 'morning' ? 'evening' : 'morning';
                const oppositeLabel = oppositePeriod === 'morning' ? 'AM' : 'PM';
                
                // Count incomplete for opposite period
                const oppositeIncomplete = symptoms.filter(s => s.active).filter(symptom => {
                  const entryKey = `${dateKey}-${symptom.id}-${oppositePeriod}`;
                  return !entries[entryKey];
                });
                
                if (oppositeIncomplete.length > 0) {
                  return (
                    <button
                      onClick={() => {
                        setQuickLogTime(oppositePeriod);
                        setRapidEntryConfirm(false);
                        setRapidEntryIndex(0);
                        setRapidEntryLogged([]);
                      }}
                      style={{
                        padding: '14px 28px',
                        background: 'rgba(16, 185, 129, 0.2)',
                        border: '1px solid rgba(16, 185, 129, 0.4)',
                        borderRadius: '5px',
                        color: '#34d399',
                        fontSize: '15px',
                        fontWeight: '600',
                        cursor: 'pointer',
                      }}
                    >
                      Switch to {oppositeLabel} ({oppositeIncomplete.length} incomplete)
                    </button>
                  );
                }
                return null;
              })()}
              
              <div style={{ color: '#94a3b8', fontSize: '14px', textAlign: 'center', marginTop: '8px' }}>
                Or start over to re-enter this period?
              </div>
              <div style={{ display: 'flex', gap: '12px' }}>
                <button
                  onClick={() => {
                    setRapidEntryMode(false);
                    setRapidEntryConfirm(false);
                  }}
                  style={{
                    padding: '12px 24px',
                    background: 'rgba(100, 116, 139, 0.1)',
                    border: '1px solid rgba(100, 116, 139, 0.3)',
                    borderRadius: '5px',
                    color: '#94a3b8',
                    fontSize: '14px',
                    fontWeight: '600',
                    cursor: 'pointer',
                  }}
                >
                  Close
                </button>
                <button
                  onClick={() => {
                    // Clear all entries for current time period and start over
                    const dateKey = selectedDate.toISOString().split('T')[0];
                    const timePeriod = quickLogTime || getCurrentTimePeriod();
                    const timeKey = trackingMode === 'ampm' ? timePeriod : 'daily';
                    
                    // Clear entries for this period
                    const newEntries = { ...entries };
                    symptoms.filter(s => s.active).forEach(symptom => {
                      const entryKey = `${dateKey}-${symptom.id}-${timeKey}`;
                      delete newEntries[entryKey];
                    });
                    setEntries(newEntries);
                    
                    setRapidEntryConfirm(false);
                    setRapidEntryIndex(0);
                    setRapidEntryLogged([]);
                  }}
                  style={{
                    padding: '12px 24px',
                    background: 'rgba(139, 92, 246, 0.2)',
                    border: '1px solid rgba(139, 92, 246, 0.4)',
                    borderRadius: '5px',
                    color: '#c4b5fd',
                    fontSize: '14px',
                    fontWeight: '600',
                    cursor: 'pointer',
                  }}
                >
                  Start Over
                </button>
              </div>
            </div>
          ) : (
            <>
          {/* Progress indicator - shows completed vs total */}
          <div style={{
            display: 'flex',
            gap: '4px',
            marginBottom: '20px',
          }}>
            {Array.from({ length: totalActiveSymptoms }).map((_, idx) => {
              const completedCount = totalActiveSymptoms - incompleteSymptoms.length;
              return (
                <div
                  key={idx}
                  style={{
                    flex: 1,
                    height: '4px',
                    borderRadius: '2px',
                    background: idx < completedCount 
                      ? '#10b981'  // Completed - green
                      : idx === completedCount
                        ? '#8b5cf6'  // Current - purple
                        : 'rgba(100, 116, 139, 0.3)',  // Pending - gray
                  }}
                />
              );
            })}
          </div>
          
          {/* Current symptom */}
          {incompleteSymptoms[rapidEntryIndex] ? (
            <div style={{
              flex: 1,
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              gap: '30px',
            }}>
              {/* Symptom name */}
              <div style={{
                color: '#f8fafc',
                fontSize: '28px',
                fontWeight: '700',
                textAlign: 'center',
              }}>
                {incompleteSymptoms[rapidEntryIndex].name}
              </div>
              
              {/* Time period indicator */}
              {timePeriods.length > 1 && (
                <div style={{
                  display: 'flex',
                  gap: '12px',
                }}>
                  {timePeriods.map(period => {
                    const currentTime = quickLogTime || getCurrentTimePeriod();
                    const isSelected = currentTime === period.id;
                    return (
                      <button
                        key={period.id}
                        onClick={() => setQuickLogTime(period.id)}
                        style={{
                          padding: '10px 20px',
                          background: isSelected ? 'rgba(139, 92, 246, 0.3)' : 'rgba(100, 116, 139, 0.1)',
                          border: isSelected ? '2px solid rgba(139, 92, 246, 0.6)' : '2px solid transparent',
                          borderRadius: '5px',
                          color: isSelected ? '#c4b5fd' : '#94a3b8',
                          fontSize: '16px',
                          fontWeight: '600',
                          cursor: 'pointer',
                        }}
                      >
                        {period.icon} {period.label}
                      </button>
                    );
                  })}
                </div>
              )}
              
              {/* Most recent value hint */}
              {(() => {
                const symptomId = incompleteSymptoms[rapidEntryIndex].id;
                const recentEntry = getMostRecentEntry(symptomId);
                if (recentEntry) {
                  return (
                    <div style={{ color: '#64748b', fontSize: '14px' }}>
                      Last recorded: <span style={{ color: severityColors[recentEntry.severity], fontWeight: '600' }}>{recentEntry.severity}</span>
                    </div>
                  );
                }
                return null;
              })()}
              
              {/* Large severity buttons */}
              <div style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(3, 1fr)',
                gap: '12px',
                width: '100%',
                maxWidth: '400px',
              }}>
                {[0, 1, 2, 3, 4, 5].map(severity => {
                  const logTime = quickLogTime || getCurrentTimePeriod();
                  const symptomId = incompleteSymptoms[rapidEntryIndex]?.id;
                  const symptomName = incompleteSymptoms[rapidEntryIndex]?.name;
                  
                  // Check most recent entry for subtle highlight
                  const recentEntry = getMostRecentEntry(symptomId);
                  const isRecentSeverity = recentEntry?.severity === severity;
                  
                  return (
                    <button
                      key={severity}
                      onClick={() => {
                        if (!symptomId) return;
                        
                        // Track this for back button
                        setRapidEntryLogged(prev => [...prev, {
                          symptomId,
                          symptomName,
                          severity,
                          time: logTime,
                        }]);
                        
                        quickLog(symptomId, severity, logTime);
                        
                        // Check if this was the last one
                        if (incompleteSymptoms.length <= 1) {
                          setRapidEntryMode(false);
                          setRapidEntryIndex(0);
                          setLastAction(`âš¡ Rapid entry complete`);
                        }
                      }}
                      style={{
                        padding: '24px',
                        background: `${severityColors[severity]}20`,
                        border: isRecentSeverity ? `2px solid ${severityColors[severity]}40` : '2px solid transparent',
                        borderRadius: '3px',
                        color: severityColors[severity],
                        fontSize: '32px',
                        fontWeight: '700',
                        cursor: 'pointer',
                      }}
                    >
                      {severity}
                    </button>
                  );
                })}
              </div>
              
              {/* Navigation buttons */}
              <div style={{ display: 'flex', gap: '12px' }}>
                {/* Back button - undo last entry */}
                <button
                  onClick={() => {
                    if (rapidEntryLogged.length > 0) {
                      const lastLogged = rapidEntryLogged[rapidEntryLogged.length - 1];
                      // Remove the entry
                      const dateKey = selectedDate.toISOString().split('T')[0];
                      const timeKey = trackingMode === 'ampm' ? lastLogged.time : 'daily';
                      const entryKey = `${dateKey}-${lastLogged.symptomId}-${timeKey}`;
                      
                      setEntries(prev => {
                        const newEntries = { ...prev };
                        delete newEntries[entryKey];
                        return newEntries;
                      });
                      
                      // Remove from logged history
                      setRapidEntryLogged(prev => prev.slice(0, -1));
                    }
                  }}
                  disabled={rapidEntryLogged.length === 0}
                  style={{
                    padding: '12px 24px',
                    background: rapidEntryLogged.length > 0 ? 'rgba(100, 116, 139, 0.1)' : 'rgba(50, 50, 70, 0.2)',
                    border: '1px solid rgba(100, 116, 139, 0.3)',
                    borderRadius: '5px',
                    color: rapidEntryLogged.length > 0 ? '#94a3b8' : '#475569',
                    fontSize: '14px',
                    fontWeight: '600',
                    cursor: rapidEntryLogged.length > 0 ? 'pointer' : 'default',
                    opacity: rapidEntryLogged.length > 0 ? 1 : 0.5,
                  }}
                >
                  â† Undo
                </button>
                
                {/* Skip/Close button */}
                <button
                onClick={() => {
                  if (incompleteSymptoms.length > 1) {
                    // Move current to end by skipping - but since list is dynamic, just close if only one left
                    setRapidEntryMode(false);
                    setRapidEntryIndex(0);
                  } else {
                    setRapidEntryMode(false);
                    setRapidEntryIndex(0);
                  }
                }}
                style={{
                  padding: '12px 32px',
                  background: 'rgba(100, 116, 139, 0.1)',
                  border: '1px solid rgba(100, 116, 139, 0.3)',
                  borderRadius: '5px',
                  color: '#94a3b8',
                  fontSize: '14px',
                  fontWeight: '600',
                  cursor: 'pointer',
                }}
              >
                Skip / Close
              </button>
              </div>
              
              {/* Counter - shows completed / total */}
              <div style={{ color: '#64748b', fontSize: '14px' }}>
                {totalActiveSymptoms - incompleteSymptoms.length} of {totalActiveSymptoms} logged â€¢ {incompleteSymptoms.length} remaining
              </div>
            </div>
          ) : (
            <div style={{
              flex: 1,
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              color: '#64748b',
            }}>
              All symptoms logged for this period âœ“
            </div>
          )}
            </>
          )}
        </div>
      )}
      
      {/* Fixed Header Area - Clean & Minimal */}
      <div style={{
        flexShrink: 0,
        padding: '12px 16px',
        zIndex: 100,
      }}>
        {/* Date Navigation Header */}
        <div 
          onTouchStart={handleSwipeStart}
          onTouchEnd={handleSwipeEnd}
          style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
          }}>
          <button
            onClick={() => changeDate(-1)}
            style={{
              background: 'rgba(99, 102, 241, 0.15)',
              border: '1px solid rgba(99, 102, 241, 0.3)',
              borderRadius: '5px',
              width: '40px',
              height: '40px',
              color: '#a5b4fc',
              fontSize: '20px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            â€¹
          </button>
          
          <button
            onClick={() => {
              setCalendarMonth(new Date(selectedDate));
              setShowCalendar(true);
            }}
            style={{
              background: 'transparent',
              border: 'none',
              cursor: 'pointer',
              textAlign: 'center',
              padding: '4px 16px',
            }}
          >
            <h1 style={{
              color: '#f8fafc',
              fontSize: '20px',
              fontWeight: '700',
              margin: 0,
            }}>
              {formatDate(selectedDate)}
            </h1>
          </button>

          {/* Right side buttons group */}
          <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
            {/* Rapid Entry Button */}
            {appMode === 'symptoms' && (
              <button
                onClick={() => {
                  // Set time period first
                  if (trackingMode === 'ampm' && !quickLogTime) {
                    setQuickLogTime(getCurrentTimePeriod());
                  }
                  
                  // Reset logged history for back button
                  setRapidEntryLogged([]);
                  
                  // Check if all symptoms are already complete
                  if (incompleteSymptoms.length === 0 && totalActiveSymptoms > 0) {
                    // Show confirmation dialog
                    setRapidEntryConfirm(true);
                    setRapidEntryMode(true);
                  } else {
                    // Normal rapid entry
                    setRapidEntryMode(true);
                    setRapidEntryIndex(0);
                  }
                }}
                style={{
                  background: 'rgba(16, 185, 129, 0.15)',
                  border: '1px solid rgba(16, 185, 129, 0.3)',
                  borderRadius: '5px',
                  width: '40px',
                  height: '40px',
                  color: '#34d399',
                  fontSize: '14px',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
                title="Rapid Entry Mode"
              >
                <svg width="18" height="18" viewBox="0 0 24 24" fill="#34d399" stroke="none">
                  <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
                </svg>
              </button>
            )}

            <button
              onClick={() => changeDate(1)}
              disabled={!canGoForward}
              style={{
                background: canGoForward ? 'rgba(99, 102, 241, 0.15)' : 'rgba(50, 50, 70, 0.3)',
                border: '1px solid rgba(99, 102, 241, 0.3)',
                borderRadius: '5px',
                width: '40px',
                height: '40px',
                color: canGoForward ? '#a5b4fc' : '#475569',
                fontSize: '20px',
                cursor: canGoForward ? 'pointer' : 'default',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                opacity: canGoForward ? 1 : 0.5,
              }}
            >
              â€º
            </button>
          </div>
        </div>
      </div>

      {/* Scrollable Content Area */}
      <div style={{
        flex: 1,
        overflowY: 'auto',
        overflowX: 'hidden',
        padding: '16px 16px 220px 16px',
        WebkitOverflowScrolling: 'touch',
      }}>
        <div style={{
          maxWidth: '800px',
          margin: '0 auto',
        }}>
        {appMode === 'symptoms' ? (
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          gap: '8px',
        }}>
        
        {/* Pull handle to reveal search */}
        {symptoms.filter(s => s.active).length > 8 && (
          <div 
            onClick={() => setSearchVisible(!searchVisible)}
            style={{
              display: 'flex',
              justifyContent: 'center',
              padding: '4px 0 8px 0',
              cursor: 'pointer',
            }}
          >
            <div style={{
              width: '40px',
              height: '4px',
              background: searchVisible ? 'rgba(99, 102, 241, 0.5)' : 'rgba(100, 116, 139, 0.3)',
              borderRadius: '2px',
            }} />
          </div>
        )}
        
        {/* Search Input - hidden by default */}
        {searchVisible && symptoms.filter(s => s.active).length > 8 && (
          <div style={{
            position: 'relative',
            marginBottom: '8px',
            animation: 'slideDown 0.2s ease',
          }}>
            <input
              type="text"
              value={symptomSearch}
              onChange={(e) => setSymptomSearch(e.target.value)}
              placeholder="Search symptoms..."
              autoFocus
              style={{
                width: '100%',
                padding: '12px 40px 12px 16px',
                background: 'rgba(30, 27, 75, 0.6)',
                border: '1px solid rgba(99, 102, 241, 0.3)',
                borderRadius: '3px',
                color: '#f8fafc',
                fontSize: '15px',
                outline: 'none',
                boxSizing: 'border-box',
              }}
            />
            {symptomSearch && (
              <button
                onClick={() => setSymptomSearch('')}
                style={{
                  position: 'absolute',
                  right: '12px',
                  top: '50%',
                  transform: 'translateY(-50%)',
                  background: 'rgba(99, 102, 241, 0.3)',
                  border: 'none',
                  borderRadius: '50%',
                  width: '24px',
                  height: '24px',
                  color: '#a5b4fc',
                  fontSize: '14px',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                âœ•
              </button>
            )}
          </div>
        )}
        
        {activeSymptoms.length === 0 && symptomSearch && (
          <div style={{
            padding: '24px',
            textAlign: 'center',
            color: '#64748b',
            fontSize: '14px',
          }}>
            No symptoms match "{symptomSearch}"
          </div>
        )}
        
        {activeSymptoms.map((symptom) => {
          const symptomEntries = getSymptomEntries(symptom.id);
          const isActive = activeSymptom === symptom.id;
          const isQuickLog = quickLogSymptom === symptom.id;
          const isPinned = pinnedSymptoms.has(symptom.id);
          
          return (
            <div key={symptom.id} style={{ position: 'relative' }}>
              {/* Always show the normal tile */}
              <div
                onTouchStart={(e) => {
                  if (isQuickLog) return;
                  handleTouchStart(e, symptom.id);
                }}
                onMouseDown={(e) => {
                  if (isQuickLog) return;
                  handleMouseDown(e, symptom.id);
                }}
                onClick={() => {
                  if (!isDragging && !isActive) {
                    // If a modal is open for ANY symptom, close it first
                    if (quickLogSymptom !== null) {
                      setQuickLogSymptom(null);
                    } else {
                      // No modal open, so open this one
                      setQuickLogSymptom(symptom.id);
                      if (trackingMode === 'ampm' && !quickLogTime) {
                        setQuickLogTime(getCurrentTimePeriod());
                      }
                    }
                  }
                }}
                style={{
                  background: isActive 
                    ? 'rgba(99, 102, 241, 0.15)' 
                    : 'rgba(30, 27, 75, 0.6)',
                  borderRadius: '5px',
                  padding: '12px 16px',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  border: isActive 
                    ? '2px solid rgba(99, 102, 241, 0.5)' 
                    : isQuickLog
                      ? '2px solid rgba(139, 92, 246, 0.5)'
                      : '2px solid transparent',
                  cursor: 'pointer',
                  transition: 'all 0.15s ease',
                  transform: isActive ? 'scale(1.02)' : 'scale(1)',
                }}
              >
                <div style={{ flex: 1, minWidth: 0, display: 'flex', alignItems: 'center', gap: '6px' }}>
                  {isPinned && (
                    <span style={{ fontSize: '12px', color: '#94a3b8' }}>âŠ™</span>
                  )}
                  <span style={{
                    color: '#e2e8f0',
                    fontSize: '15px',
                    fontWeight: '600',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap',
                  }}>{symptom.name}</span>
                </div>
                
                <div style={{
                  display: 'flex',
                  gap: '4px',
                  justifyContent: 'flex-end',
                  alignItems: 'center',
                  marginLeft: '12px',
                  minWidth: timePeriods.length > 1 ? '80px' : '40px',
                }}>
                  {symptomEntries.length === 0 ? (
                    <span style={{ color: '#64748b', fontSize: '11px', textAlign: 'right' }}>
                      Tap to log
                    </span>
                  ) : (
                    timePeriods.map((period) => {
                      const entry = symptomEntries.find(e => e.time === period.id);
                      if (!entry) {
                        return <div key={period.id} style={{ width: '36px' }} />;
                      }
                      return (
                        <div 
                          key={period.id} 
                          onClick={(e) => {
                            e.stopPropagation();
                            clearEntry(symptom.id, entry.time);
                          }}
                          style={{
                            background: `${severityColors[entry.severity]}25`,
                            border: 'none',
                            borderRadius: '3px',
                            padding: '4px 6px',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '3px',
                            cursor: 'pointer',
                          }}
                        >
                          <span style={{ fontSize: '10px', color: '#94a3b8' }}>
                            {period.icon}
                          </span>
                          <span style={{
                            color: severityColors[entry.severity],
                            fontSize: '13px',
                            fontWeight: '700',
                          }}>{entry.severity}</span>
                        </div>
                      );
                    })
                  )}
                </div>
              </div>
              
              {/* OVERLAY - severity picker positioned over the tile */}
              {isQuickLog && (
                <div style={{
                  position: 'absolute',
                  top: '-45px',
                  left: 0,
                  right: 0,
                  zIndex: 100,
                  background: 'rgba(30, 27, 75, 0.98)',
                  border: '2px solid rgba(139, 92, 246, 0.5)',
                  borderRadius: '5px',
                  boxShadow: '0 4px 20px rgba(0,0,0,0.4)',
                  overflow: 'hidden',
                }}>
                  {/* Header - Logging symptom to AM/PM - ABOVE buttons */}
                  <div 
                    onClick={() => setQuickLogSymptom(null)}
                    style={{
                      padding: '8px 16px',
                      textAlign: 'center',
                      cursor: 'pointer',
                      borderBottom: '1px solid rgba(139, 92, 246, 0.2)',
                      background: 'rgba(139, 92, 246, 0.1)',
                    }}
                  >
                    <span style={{ color: '#c4b5fd', fontSize: '12px', fontWeight: '500' }}>
                      Logging <span style={{ color: '#e2e8f0', fontWeight: '600' }}>{symptom.name}</span>
                      {timePeriods.length > 1 && (() => {
                        const currentTime = quickLogTime || getCurrentTimePeriod();
                        const currentPeriod = timePeriods.find(p => p.id === currentTime);
                        return ` to ${currentPeriod?.icon} ${currentPeriod?.label}`;
                      })()}
                    </span>
                  </div>
                  
                  {/* Severity buttons - aligned with original tile position */}
                  <div style={{
                    padding: '12px 16px',
                    display: 'flex',
                    justifyContent: 'space-between',
                    gap: '6px',
                  }}>
                    {[0, 1, 2, 3, 4, 5].map(severity => {
                      const logTime = quickLogTime || getCurrentTimePeriod();
                      // Check most recent entry for this symptom
                      const recentEntry = getMostRecentEntry(symptom.id);
                      const isRecentSeverity = recentEntry?.severity === severity;
                      
                      return (
                        <button
                          key={severity}
                          onClick={(e) => {
                            e.stopPropagation();
                            quickLog(symptom.id, severity, logTime);
                          }}
                          style={{
                            flex: 1,
                            padding: '12px 0',
                            background: `${severityColors[severity]}20`,
                            border: isRecentSeverity ? `1px solid ${severityColors[severity]}35` : '1px solid transparent',
                            borderRadius: '3px',
                            color: severityColors[severity],
                            fontSize: '18px',
                            fontWeight: '700',
                            cursor: 'pointer',
                          }}
                        >
                          {severity}
                        </button>
                      );
                    })}
                  </div>
                  
                  {/* Pin and AM/PM buttons */}
                  <div style={{
                    padding: '8px 16px 12px',
                    display: 'flex',
                    gap: '8px',
                  }}>
                    {/* Pin button */}
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        togglePin(symptom.id);
                        setQuickLogSymptom(null); // Close overlay after pinning
                      }}
                      style={{
                        flex: 1,
                        padding: '8px',
                        background: isPinned ? 'rgba(251, 191, 36, 0.15)' : 'rgba(100, 116, 139, 0.1)',
                        border: isPinned ? '1px solid rgba(251, 191, 36, 0.4)' : '1px solid rgba(100, 116, 139, 0.3)',
                        borderRadius: '3px',
                        color: isPinned ? '#fbbf24' : '#94a3b8',
                        fontSize: '12px',
                        fontWeight: '600',
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: '6px',
                      }}
                    >
                      <span style={{ fontSize: '14px' }}>âŠ™</span> {isPinned ? 'Unpin' : 'Pin'}
                    </button>
                    
                    {/* AM/PM toggle */}
                    {timePeriods.length > 1 && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          const currentTime = quickLogTime || getCurrentTimePeriod();
                          const nextTime = currentTime === 'morning' ? 'evening' : 'morning';
                          setQuickLogTime(nextTime);
                        }}
                        style={{
                          flex: 1,
                          padding: '8px',
                          background: 'rgba(99, 102, 241, 0.15)',
                          border: '1px solid rgba(99, 102, 241, 0.4)',
                          borderRadius: '3px',
                          color: '#a5b4fc',
                          fontSize: '12px',
                          fontWeight: '600',
                          cursor: 'pointer',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: '6px',
                        }}
                      >
                        {(() => {
                          const currentTime = quickLogTime || getCurrentTimePeriod();
                          const currentPeriod = timePeriods.find(p => p.id === currentTime);
                          return `${currentPeriod?.icon} ${currentPeriod?.label}`;
                        })()}
                      </button>
                    )}
                  </div>
                </div>
              )}
            </div>
          );
        })}

        {/* Daily Notes */}
        <div style={{
          background: 'rgba(30, 27, 75, 0.6)',
          borderRadius: '5px',
          padding: '14px 16px',
          marginTop: '8px',
        }}>
          <span style={{ color: '#94a3b8', fontSize: '12px', fontWeight: '600', textTransform: 'uppercase', letterSpacing: '0.5px', display: 'block', marginBottom: '8px' }}>
            Notes for {selectedDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
          </span>
          <textarea
            ref={notesTextareaRef}
            value={dailyNotes[getDateKey(selectedDate)] || ''}
            onChange={(e) => {
              const dateKey = getDateKey(selectedDate);
              setDailyNotes(prev => ({
                ...prev,
                [dateKey]: e.target.value
              }));
            }}
            placeholder="Add notes about today... (diet, sleep, stress, activities, etc.)"
            style={{
              width: '100%',
              minHeight: '80px',
              background: 'rgba(15, 10, 46, 0.5)',
              border: '1px solid rgba(99, 102, 241, 0.2)',
              borderRadius: '5px',
              padding: '12px',
              color: '#e2e8f0',
              fontSize: '14px',
              resize: 'vertical',
              fontFamily: 'inherit',
            }}
          />
        </div>

        <button
          onClick={() => setShowAddSymptom(true)}
          style={{
            background: 'transparent',
            border: '2px dashed rgba(99, 102, 241, 0.3)',
            borderRadius: '5px',
            padding: '16px',
            color: '#6366f1',
            fontSize: '15px',
            fontWeight: '500',
            cursor: 'pointer',
            marginTop: '4px',
          }}
        >
          + Manage Symptoms
        </button>
        </div>
        ) : (
        /* Stack Mode */
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          gap: '8px',
        }}>
          {/* Progress indicator and actions */}
          {stackItems.filter(i => i.active).length > 0 && (
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '8px',
              gap: '8px',
            }}>
              <button
                onClick={() => {
                  const dateKey = getDateKey(selectedDate);
                  const newEntries = { ...stackEntries };
                  stackItems.filter(i => i.active).forEach(item => {
                    const entryKey = `${dateKey}-${item.id}`;
                    newEntries[entryKey] = {
                      date: dateKey,
                      itemId: item.id,
                      dose: item.defaultDose,
                      taken: true
                    };
                  });
                  setStackEntries(newEntries);
                  haptic('success');
                  setLastAction('All selected');
                }}
                style={{
                  background: 'rgba(74, 222, 128, 0.1)',
                  border: '1px solid rgba(74, 222, 128, 0.3)',
                  borderRadius: '3px',
                  color: '#4ade80',
                  fontSize: '11px',
                  fontWeight: '600',
                  cursor: 'pointer',
                  padding: '6px 10px',
                }}
              >
                âœ“ All
              </button>
              <span style={{ color: '#94a3b8', fontSize: '13px', fontWeight: '600' }}>
                {getStackProgress().taken}/{getStackProgress().total}
              </span>
              <button
                onClick={() => {
                  const dateKey = getDateKey(selectedDate);
                  const newEntries = { ...stackEntries };
                  Object.keys(newEntries).forEach(key => {
                    if (key.startsWith(dateKey)) {
                      delete newEntries[key];
                    }
                  });
                  setStackEntries(newEntries);
                  setLastAction('All cleared');
                }}
                style={{
                  background: 'rgba(248, 113, 113, 0.1)',
                  border: '1px solid rgba(248, 113, 113, 0.3)',
                  borderRadius: '3px',
                  color: '#f87171',
                  fontSize: '11px',
                  fontWeight: '600',
                  cursor: 'pointer',
                  padding: '6px 10px',
                }}
              >
                âœ• Clear
              </button>
            </div>
          )}

          {stackItems.filter(i => i.active).sort((a, b) => (a.order || 0) - (b.order || 0)).map((item) => {
            const entry = getStackEntry(item.id);
            const isTaken = !!entry;
            const isEditing = editingStackItem === item.id;
            const multiplier = entry?.multiplier || 1;
            
            return (
              <div
                key={item.id}
                style={{
                  background: isTaken 
                    ? multiplier > 1 
                      ? 'rgba(139, 92, 246, 0.1)'  // Purple tint for multiplied
                      : 'rgba(34, 197, 94, 0.1)' 
                    : 'rgba(30, 27, 75, 0.6)',
                  borderRadius: '5px',
                  padding: '14px 16px',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  border: isTaken 
                    ? multiplier > 1
                      ? '1px solid rgba(139, 92, 246, 0.4)'  // Purple border for multiplied
                      : '1px solid rgba(34, 197, 94, 0.3)' 
                    : '1px solid transparent',
                  cursor: 'pointer',
                  transition: 'all 0.15s ease',
                }}
                onClick={() => !isEditing && toggleStackItem(item.id)}
              >
                <div style={{ display: 'flex', alignItems: 'center', gap: '10px', flex: 1 }}>
                  {/* Multiplier button - more prominent */}
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      if (!isTaken) return;
                      haptic('light');
                      const dateKey = getDateKey(selectedDate);
                      const entryKey = `${dateKey}-${item.id}`;
                      const currentMultiplier = entry?.multiplier || 1;
                      const nextMultiplier = currentMultiplier >= 3 ? 1 : currentMultiplier + 1;
                      setStackEntries(prev => ({
                        ...prev,
                        [entryKey]: {
                          ...prev[entryKey],
                          multiplier: nextMultiplier,
                        }
                      }));
                    }}
                    style={{
                      minWidth: multiplier > 1 ? '36px' : '32px',
                      height: multiplier > 1 ? '36px' : '32px',
                      borderRadius: '3px',
                      background: isTaken 
                        ? multiplier > 1 
                          ? 'linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%)' 
                          : 'rgba(34, 197, 94, 0.2)'
                        : 'rgba(100, 116, 139, 0.15)',
                      border: isTaken 
                        ? multiplier > 1 
                          ? '2px solid rgba(167, 139, 250, 0.6)' 
                          : '1px solid rgba(34, 197, 94, 0.3)'
                        : '1px solid transparent',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      color: isTaken 
                        ? multiplier > 1 
                          ? '#fff' 
                          : '#22c55e'
                        : '#475569',
                      fontSize: multiplier > 1 ? '14px' : '12px',
                      fontWeight: '700',
                      cursor: isTaken ? 'pointer' : 'default',
                      opacity: isTaken ? 1 : 0.4,
                      flexShrink: 0,
                      transition: 'all 0.15s ease',
                      boxShadow: multiplier > 1 ? '0 2px 8px rgba(139, 92, 246, 0.4)' : 'none',
                    }}
                  >
                    {multiplier}x
                  </button>
                  
                  {/* Checkbox */}
                  <div style={{
                    width: '24px',
                    height: '24px',
                    borderRadius: '3px',
                    background: isTaken ? '#22c55e' : 'rgba(100, 116, 139, 0.3)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: isTaken ? '#fff' : '#64748b',
                    fontSize: '14px',
                    fontWeight: '700',
                    flexShrink: 0,
                  }}>
                    {isTaken ? 'âœ“' : ''}
                  </div>
                  
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                    <span style={{
                      color: isTaken ? '#e2e8f0' : '#94a3b8',
                      fontSize: '15px',
                      fontWeight: '500',
                    }}>{item.name}</span>
                    {multiplier > 1 && (
                      <span style={{
                        color: '#a78bfa',
                        fontSize: '11px',
                        fontWeight: '600',
                      }}>
                        {multiplier}Ã— dose today
                      </span>
                    )}
                  </div>
                </div>
                
                {isEditing ? (
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}
                       onClick={(e) => e.stopPropagation()}>
                    <input
                      type="text"
                      inputMode="decimal"
                      defaultValue={entry?.dose || item.defaultDose}
                      autoFocus
                      style={{
                        width: '60px',
                        background: 'rgba(99, 102, 241, 0.15)',
                        border: '2px solid rgba(99, 102, 241, 0.5)',
                        borderRadius: '3px',
                        padding: '8px 10px',
                        color: '#f8fafc',
                        fontSize: '16px',
                        fontWeight: '600',
                        textAlign: 'center',
                        outline: 'none',
                      }}
                      onFocus={(e) => e.target.select()}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                          updateStackDose(item.id, e.target.value);
                        } else if (e.key === 'Escape') {
                          setEditingStackItem(null);
                        }
                      }}
                      onBlur={(e) => updateStackDose(item.id, e.target.value)}
                    />
                    <span style={{ color: '#94a3b8', fontSize: '13px', fontWeight: '500' }}>{item.unit}</span>
                  </div>
                ) : (
                  <div 
                    style={{ 
                      display: 'flex', 
                      alignItems: 'baseline', 
                      gap: '4px',
                      padding: '4px 8px',
                      borderRadius: '3px',
                      background: isTaken ? 'rgba(34, 197, 94, 0.15)' : 'transparent',
                    }}
                    onClick={(e) => {
                      e.stopPropagation();
                      setEditingStackItem(item.id);
                    }}
                  >
                    <span style={{
                      color: isTaken ? '#4ade80' : '#64748b',
                      fontSize: '15px',
                      fontWeight: '600',
                    }}>
                      {entry?.dose || item.defaultDose}
                    </span>
                    <span style={{
                      color: isTaken ? '#4ade80' : '#64748b',
                      fontSize: '11px',
                    }}>
                      {item.unit}
                    </span>
                  </div>
                )}
              </div>
            );
          })}

          <button
            onClick={() => setShowManageStack(true)}
            style={{
              background: 'transparent',
              border: '2px dashed rgba(99, 102, 241, 0.3)',
              borderRadius: '5px',
              padding: '16px',
              color: '#6366f1',
              fontSize: '15px',
              fontWeight: '500',
              cursor: 'pointer',
              marginTop: '4px',
            }}
          >
            + Manage Stack
          </button>
        </div>
        )}
        </div>{/* Close max-width wrapper */}
      </div>

      {/* Floating Add Note Button - only in symptoms mode */}
      {appMode === 'symptoms' && !showInsights && !showSettings && !showHistory && !showExport && !showCalendar && !showAddSymptom && (
        <button
          onClick={scrollToNotes}
          style={{
            position: 'fixed',
            bottom: 'calc(75px + env(safe-area-inset-bottom))',
            right: '12px',
            background: 'rgba(99, 102, 241, 0.15)',
            border: '1px solid rgba(99, 102, 241, 0.3)',
            borderRadius: '5px',
            padding: '12px 14px',
            color: '#a5b4fc',
            fontSize: '13px',
            fontWeight: '500',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            gap: '6px',
            zIndex: 150,
          }}
        >
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M12 20h9"/>
            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/>
          </svg>
          Note
        </button>
      )}

      {/* Bottom Tab Bar */}
      <div style={{
        position: 'fixed',
        bottom: 0,
        left: 0,
        right: 0,
        background: 'linear-gradient(180deg, rgba(12, 10, 29, 0.95) 0%, #0c0a1d 100%)',
        borderTop: '1px solid rgba(99, 102, 241, 0.2)',
        display: 'flex',
        padding: '8px 16px',
        paddingBottom: 'max(8px, env(safe-area-inset-bottom))',
        zIndex: 200,
      }}>
        <button
          onClick={() => { setAppMode('symptoms'); setShowInsights(false); setShowSettings(false); setQuickLogSymptom(null); setQuickLogTime(null); }}
          style={{
            flex: 1,
            background: appMode === 'symptoms' && !showInsights && !showSettings ? 'rgba(99, 102, 241, 0.15)' : 'transparent',
            border: 'none',
            borderRadius: '3px',
            padding: '12px 8px',
            cursor: 'pointer',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '4px',
            position: 'relative',
          }}
        >
          <div style={{ position: 'relative' }}>
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke={appMode === 'symptoms' && !showInsights && !showSettings ? '#a5b4fc' : '#64748b'} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M22 12h-4l-3 9L9 3l-3 9H2"/>
            </svg>
            {tabBadges.symptoms.status === 'none' && (
              <span style={{
                position: 'absolute',
                top: '-2px',
                right: '-2px',
                width: '8px',
                height: '8px',
                borderRadius: '50%',
                background: '#ef4444',
                border: '1.5px solid #0c0a1d',
              }} />
            )}
          </div>
          <span style={{
            color: appMode === 'symptoms' && !showInsights && !showSettings ? '#a5b4fc' : '#64748b',
            fontSize: '11px',
            fontWeight: appMode === 'symptoms' && !showInsights && !showSettings ? '600' : '400',
          }}>Symptoms</span>
        </button>
        <button
          onClick={() => { setAppMode('stack'); setShowInsights(false); setShowSettings(false); setQuickLogSymptom(null); setQuickLogTime(null); }}
          style={{
            flex: 1,
            background: appMode === 'stack' && !showInsights && !showSettings ? 'rgba(99, 102, 241, 0.15)' : 'transparent',
            border: 'none',
            borderRadius: '3px',
            padding: '12px 8px',
            cursor: 'pointer',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '4px',
            position: 'relative',
          }}
        >
          <div style={{ position: 'relative' }}>
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke={appMode === 'stack' && !showInsights && !showSettings ? '#a5b4fc' : '#64748b'} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M10.5 20.5L3.5 13.5a4.95 4.95 0 1 1 7-7l7 7a4.95 4.95 0 1 1-7 7z"/>
              <line x1="8.5" y1="8.5" x2="15.5" y2="15.5"/>
            </svg>
          </div>
          <span style={{
            color: appMode === 'stack' && !showInsights && !showSettings ? '#a5b4fc' : '#64748b',
            fontSize: '11px',
            fontWeight: appMode === 'stack' && !showInsights && !showSettings ? '600' : '400',
          }}>Stack</span>
        </button>
        <button
          onClick={() => { setShowInsights(true); setShowSettings(false); setQuickLogSymptom(null); setQuickLogTime(null); }}
          style={{
            flex: 1,
            background: showInsights ? 'rgba(99, 102, 241, 0.15)' : 'transparent',
            border: 'none',
            borderRadius: '3px',
            padding: '12px 8px',
            cursor: 'pointer',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '4px',
          }}
        >
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke={showInsights ? '#a5b4fc' : '#64748b'} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <line x1="18" y1="20" x2="18" y2="10"/>
            <line x1="12" y1="20" x2="12" y2="4"/>
            <line x1="6" y1="20" x2="6" y2="14"/>
          </svg>
          <span style={{
            color: showInsights ? '#a5b4fc' : '#64748b',
            fontSize: '11px',
            fontWeight: showInsights ? '600' : '400',
          }}>Insights</span>
        </button>
        <button
          onClick={() => { setShowSettings(true); setShowInsights(false); setQuickLogSymptom(null); setQuickLogTime(null); }}
          style={{
            flex: 1,
            background: showSettings ? 'rgba(99, 102, 241, 0.15)' : 'transparent',
            border: 'none',
            borderRadius: '3px',
            padding: '12px 8px',
            cursor: 'pointer',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '4px',
          }}
        >
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke={showSettings ? '#a5b4fc' : '#64748b'} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <circle cx="12" cy="12" r="3"/>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
          </svg>
          <span style={{
            color: showSettings ? '#a5b4fc' : '#64748b',
            fontSize: '11px',
            fontWeight: showSettings ? '600' : '400',
          }}>Settings</span>
        </button>
      </div>

      {/* 2D Drag Picker Overlay - Simplified Full Screen */}
      {isDragging && activeSymptom && (
        <div style={{
          position: 'fixed',
          inset: 0,
          background: '#0a1628',
          display: 'flex',
          flexDirection: 'column',
          zIndex: 1000,
          touchAction: 'none',
        }}>
          {/* Severity color bar at very top */}
          <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            height: '5px',
            background: severityColors[dragPosition.y],
            zIndex: 1002,
            transition: 'background 0.1s ease',
          }} />

          {/* Screen zone indicators - 5 vertical sections */}
          <div style={{
            position: 'absolute',
            inset: 0,
            display: 'flex',
            pointerEvents: 'none',
          }}>
            {timePeriods.map((period, idx) => (
              <div 
                key={period.id}
                style={{
                  flex: 1,
                  borderRight: idx < 4 ? '1px solid rgba(99, 102, 241, 0.15)' : 'none',
                  background: dragPosition.x === idx ? 'rgba(99, 102, 241, 0.08)' : 'transparent',
                  transition: 'background 0.1s ease',
                }}
              />
            ))}
          </div>

          {/* Top zone - Time period icons (hidden in simple mode) */}
          {trackingMode !== 'simple' && (
            <div style={{
              position: 'fixed',
              top: 5,
              left: 0,
              right: 0,
              display: 'flex',
              background: 'linear-gradient(180deg, #0a1628 0%, #0c1929 100%)',
            }}>
              {timePeriods.map((period, idx) => (
                <div 
                  key={period.id}
                  style={{
                    flex: 1,
                    padding: '24px 8px 16px',
                    textAlign: 'center',
                    background: dragPosition.x === idx ? 'rgba(99, 102, 241, 0.25)' : 'transparent',
                    borderRight: idx < timePeriods.length - 1 ? '1px solid rgba(99, 102, 241, 0.1)' : 'none',
                    transition: 'background 0.1s ease',
                  }}
                >
                  <div style={{
                    fontSize: '28px',
                    marginBottom: '4px',
                    opacity: dragPosition.x === idx ? 1 : 0.6,
                    transition: 'opacity 0.1s',
                    color: dragPosition.x === idx ? '#fff' : '#a5b4fc',
                  }}>
                    {period.icon}
                  </div>
                  <div style={{
                    fontSize: '11px',
                    color: dragPosition.x === idx ? '#fff' : '#94a3b8',
                    fontWeight: dragPosition.x === idx ? '700' : '500',
                    textTransform: 'uppercase',
                    letterSpacing: '0.5px',
                    transition: 'all 0.1s',
                  }}>
                    {period.label}
                  </div>
                </div>
              ))}
            </div>
          )}

          {/* Symptom Name - below time icons */}
          <div style={{
            paddingTop: trackingMode === 'simple' ? '40px' : '120px',
            textAlign: 'center',
          }}>
            <h1 style={{
              color: '#f8fafc',
              fontSize: '28px',
              fontWeight: '700',
              margin: 0,
              padding: '0 24px',
            }}>
              {currentSymptomName}
            </h1>
          </div>

          {/* Big Floating Number - Follows finger, stays below header */}
          {(() => {
            // Calculate horizontal offset for AM/PM mode to avoid finger
            let xOffset = 0;
            if (timePeriods.length === 2) {
              // AM/PM mode: offset away from finger
              xOffset = dragPosition.x === 0 ? 80 : -80; // AM=right offset, PM=left offset
            }
            const baseX = Math.max(60, Math.min(window.innerWidth - 60, fingerPosition.x + xOffset));
            
            return (
              <div style={{
                position: 'fixed',
                left: `${baseX}px`,
                top: `${Math.max(230, Math.min(window.innerHeight - 150, fingerPosition.y - 130))}px`,
                transform: 'translate(-50%, -50%)',
                pointerEvents: 'none',
                zIndex: 1001,
                textAlign: 'center',
              }}>
                <div style={{
                  fontSize: '120px',
                  fontWeight: '800',
                  color: severityColors[dragPosition.y],
                  textShadow: `0 0 30px ${severityColors[dragPosition.y]}80`,
                  lineHeight: 1,
                  transition: 'color 0.1s ease, text-shadow 0.1s ease',
                }}>
                  {dragPosition.y}
                </div>
                <div style={{
                  color: '#94a3b8',
                  fontSize: '14px',
                  fontWeight: '500',
                  marginTop: '8px',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                }}>
                  {severityLabels[dragPosition.y]}
                </div>
              </div>
            );
          })()}
        </div>
      )}

      {/* Calendar Modal */}
      {showCalendar && (
        <div 
          onClick={() => setShowCalendar(false)}
          style={{
            position: 'fixed',
            inset: 0,
            background: 'rgba(0, 0, 0, 0.92)',
            zIndex: 1000,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            padding: '20px',
          }}
        >
          <div 
            onClick={(e) => e.stopPropagation()}
            style={{
              background: '#1a1333',
              borderRadius: '5px',
              padding: '24px',
              width: '100%',
              maxWidth: '380px',
              border: '2px solid rgba(99, 102, 241, 0.3)',
            }}
          >
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '20px',
            }}>
              <button
                onClick={() => {
                  const newMonth = new Date(calendarMonth);
                  newMonth.setMonth(newMonth.getMonth() - 1);
                  setCalendarMonth(newMonth);
                }}
                style={{
                  background: 'rgba(99, 102, 241, 0.2)',
                  border: 'none',
                  borderRadius: '3px',
                  width: '52px',
                  height: '52px',
                  color: '#a5b4fc',
                  fontSize: '24px',
                  cursor: 'pointer',
                }}
              >
                â€¹
              </button>
              
              <h2 style={{
                color: '#f8fafc',
                fontSize: '20px',
                fontWeight: '700',
                margin: 0,
              }}>
                {calendarMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}
              </h2>
              
              <button
                onClick={() => {
                  const newMonth = new Date(calendarMonth);
                  newMonth.setMonth(newMonth.getMonth() + 1);
                  setCalendarMonth(newMonth);
                }}
                style={{
                  background: 'rgba(99, 102, 241, 0.2)',
                  border: 'none',
                  borderRadius: '3px',
                  width: '52px',
                  height: '52px',
                  color: '#a5b4fc',
                  fontSize: '24px',
                  cursor: 'pointer',
                }}
              >
                â€º
              </button>
            </div>

            <div style={{
              display: 'grid',
              gridTemplateColumns: 'repeat(7, 1fr)',
              gap: '4px',
              marginBottom: '8px',
            }}>
              {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, idx) => (
                <div key={idx} style={{
                  textAlign: 'center',
                  color: '#64748b',
                  fontSize: '13px',
                  fontWeight: '600',
                  padding: '8px 0',
                }}>
                  {day}
                </div>
              ))}
            </div>

            <div style={{
              display: 'grid',
              gridTemplateColumns: 'repeat(7, 1fr)',
              gap: '4px',
            }}>
              {getCalendarDays().map((day, idx) => {
                if (!day) return <div key={idx} style={{ aspectRatio: '1' }} />;
                
                const dateKey = getDateKey(day);
                const hasEntries = daysWithEntries.has(dateKey);
                const dayData = daySeverityMap[dateKey];
                const avgSeverity = dayData?.avg || 0;
                const isSelected = dateKey === getDateKey(selectedDate);
                const isToday = dateKey === getDateKey(new Date());
                const today = new Date();
                today.setHours(23, 59, 59, 999);
                const isFuture = day > today;
                
                // Heat map colors based on average severity
                const getHeatColor = (severity) => {
                  if (severity < 1) return 'rgba(74, 222, 128, 0.2)';  // green - good
                  if (severity < 2) return 'rgba(163, 230, 53, 0.2)';  // yellow-green
                  if (severity < 3) return 'rgba(250, 204, 21, 0.25)'; // yellow
                  if (severity < 4) return 'rgba(251, 146, 60, 0.25)'; // orange
                  return 'rgba(239, 68, 68, 0.25)';                    // red - bad
                };
                
                const getDotColor = (severity) => {
                  if (severity < 1) return '#4ade80';  // green
                  if (severity < 2) return '#a3e635';  // yellow-green
                  if (severity < 3) return '#facc15';  // yellow
                  if (severity < 4) return '#fb923c';  // orange
                  return '#ef4444';                    // red
                };
                
                return (
                  <button
                    key={idx}
                    onClick={() => !isFuture && selectDate(day)}
                    disabled={isFuture}
                    style={{
                      aspectRatio: '1',
                      borderRadius: '3px',
                      border: isSelected ? '2px solid #6366f1' : isToday ? '2px solid rgba(99, 102, 241, 0.4)' : '2px solid transparent',
                      background: isFuture 
                        ? 'rgba(30, 27, 75, 0.2)' 
                        : isSelected 
                          ? 'rgba(99, 102, 241, 0.3)' 
                          : hasEntries 
                            ? getHeatColor(avgSeverity) 
                            : 'rgba(30, 27, 75, 0.5)',
                      color: isFuture ? '#475569' : isSelected ? '#fff' : hasEntries ? getDotColor(avgSeverity) : '#94a3b8',
                      fontSize: '16px',
                      fontWeight: isSelected || isToday ? '700' : '500',
                      cursor: isFuture ? 'default' : 'pointer',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      position: 'relative',
                      opacity: isFuture ? 0.4 : 1,
                    }}
                  >
                    {day.getDate()}
                    {hasEntries && !isSelected && !isFuture && (
                      <div style={{
                        position: 'absolute',
                        bottom: '6px',
                        width: '4px',
                        height: '4px',
                        borderRadius: '50%',
                        background: getDotColor(avgSeverity),
                      }} />
                    )}
                  </button>
                );
              })}
            </div>

            <button
              onClick={() => selectDate(new Date())}
              style={{
                width: '100%',
                marginTop: '16px',
                padding: '14px',
                background: 'rgba(99, 102, 241, 0.2)',
                border: '1px solid rgba(99, 102, 241, 0.3)',
                borderRadius: '3px',
                color: '#a5b4fc',
                fontSize: '15px',
                fontWeight: '600',
                cursor: 'pointer',
              }}
            >
              Go to Today
            </button>
          </div>
        </div>
      )}

      {/* Manage Symptoms Modal */}
      {showAddSymptom && (
        <div 
          onClick={() => setShowAddSymptom(false)}
          style={{
            position: 'fixed',
            inset: 0,
            background: 'rgba(0, 0, 0, 0.92)',
            zIndex: 1000,
            overflowY: 'auto',
            padding: '20px',
          }}
        >
          <div 
            onClick={(e) => e.stopPropagation()}
            style={{ maxWidth: '400px', margin: '0 auto' }}
          >
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '20px',
            }}>
              <h2 style={{ color: '#f8fafc', fontSize: '22px', fontWeight: '700', margin: 0 }}>
                Manage Symptoms
              </h2>
              <button
                onClick={() => setShowAddSymptom(false)}
                style={{
                  background: 'rgba(99, 102, 241, 0.2)',
                  border: 'none',
                  borderRadius: '5px',
                  width: '44px',
                  height: '44px',
                  color: '#a5b4fc',
                  fontSize: '20px',
                  cursor: 'pointer',
                }}
              >
                âœ•
              </button>
            </div>

            <div style={{
              background: 'rgba(30, 27, 75, 0.6)',
              borderRadius: '3px',
              padding: '16px',
              marginBottom: '20px',
            }}>
              <label style={{
                color: '#94a3b8',
                fontSize: '12px',
                textTransform: 'uppercase',
                letterSpacing: '1px',
              }}>Add Multiple Symptoms</label>
              <p style={{
                color: '#64748b',
                fontSize: '12px',
                margin: '4px 0 10px 0',
              }}>
                Paste or type symptoms separated by commas, tabs, or new lines
              </p>
              <textarea
                value={bulkSymptomInput}
                onChange={(e) => setBulkSymptomInput(e.target.value)}
                placeholder="Headache, Fatigue, Nausea&#10;Back Pain&#10;Insomnia, Anxiety"
                rows={4}
                style={{
                  width: '100%',
                  background: 'rgba(15, 23, 42, 0.8)',
                  border: '2px solid rgba(99, 102, 241, 0.3)',
                  borderRadius: '5px',
                  padding: '12px 14px',
                  color: '#f8fafc',
                  fontSize: '15px',
                  outline: 'none',
                  resize: 'vertical',
                  fontFamily: 'inherit',
                }}
              />
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '10px' }}>
                <span style={{ color: '#64748b', fontSize: '12px' }}>
                  {parseBulkSymptoms(bulkSymptomInput).length} symptom(s) detected
                </span>
                <button
                  onClick={addBulkSymptoms}
                  disabled={parseBulkSymptoms(bulkSymptomInput).length === 0}
                  style={{
                    background: parseBulkSymptoms(bulkSymptomInput).length > 0 ? '#6366f1' : 'rgba(99, 102, 241, 0.3)',
                    border: 'none',
                    borderRadius: '5px',
                    padding: '10px 20px',
                    color: '#fff',
                    fontSize: '14px',
                    fontWeight: '600',
                    cursor: parseBulkSymptoms(bulkSymptomInput).length > 0 ? 'pointer' : 'not-allowed',
                  }}
                >
                  Add All
                </button>
              </div>
            </div>

            {activeSymptoms.length > 0 && (
              <div style={{ marginBottom: '20px' }}>
                <label style={{
                  color: '#94a3b8',
                  fontSize: '12px',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                }}>Active Symptoms</label>
                <p style={{ color: '#64748b', fontSize: '11px', margin: '4px 0 12px 0' }}>
                  Hold â‰¡ to reorder â€¢ Swipe left to hide â€¢ Tap to edit
                </p>
                <div 
                  style={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '8px',
                    position: 'relative',
                  }}
                  onTouchMove={handleReorderMove}
                  onTouchEnd={handleReorderEnd}
                  onMouseMove={handleReorderMove}
                  onMouseUp={handleReorderEnd}
                  onMouseLeave={handleReorderEnd}
                >
                  {activeSymptoms.map((symptom, index) => (
                    <div
                      key={symptom.id}
                      data-reorder-item
                      style={{
                        position: 'relative',
                        overflow: draggedItem?.id === symptom.id ? 'visible' : 'hidden',
                        borderRadius: '5px',
                        ...getReorderTransform(index, 'symptom'),
                      }}
                    >
                      {editingSymptomId === symptom.id ? (
                        <div style={{
                          display: 'flex',
                          gap: '8px',
                          padding: '4px',
                        }}>
                          <input
                            type="text"
                            value={editingSymptomName}
                            onChange={(e) => setEditingSymptomName(e.target.value)}
                            onKeyDown={(e) => {
                              if (e.key === 'Enter') saveSymptomName();
                              if (e.key === 'Escape') cancelEditingSymptom();
                            }}
                            autoFocus
                            style={{
                              flex: 1,
                              background: 'rgba(99, 102, 241, 0.2)',
                              border: '2px solid rgba(99, 102, 241, 0.5)',
                              borderRadius: '3px',
                              padding: '10px 12px',
                              color: '#fff',
                              fontSize: '14px',
                              outline: 'none',
                            }}
                          />
                          <button
                            onClick={saveSymptomName}
                            style={{
                              background: 'rgba(74, 222, 128, 0.2)',
                              border: '2px solid rgba(74, 222, 128, 0.4)',
                              borderRadius: '3px',
                              padding: '10px 14px',
                              color: '#86efac',
                              fontSize: '14px',
                              cursor: 'pointer',
                            }}
                          >
                            âœ“
                          </button>
                          <button
                            onClick={cancelEditingSymptom}
                            style={{
                              background: 'rgba(239, 68, 68, 0.15)',
                              border: '2px solid rgba(239, 68, 68, 0.3)',
                              borderRadius: '3px',
                              padding: '10px 14px',
                              color: '#fca5a5',
                              fontSize: '14px',
                              cursor: 'pointer',
                            }}
                          >
                            âœ•
                          </button>
                        </div>
                      ) : (
                        <>
                          {/* Delete action revealed on swipe */}
                          <div style={{
                            position: 'absolute',
                            right: 0,
                            top: 0,
                            bottom: 0,
                            width: '80px',
                            background: '#ef4444',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            borderRadius: '5px',
                          }}>
                            <span style={{ color: '#fff', fontWeight: '600', fontSize: '13px' }}>Hide</span>
                          </div>
                          {/* Swipeable content */}
                          <div
                            onTouchStart={(e) => {
                              if (!draggedItem) handleItemSwipeStart(e, symptom.id);
                            }}
                            onTouchMove={(e) => {
                              if (!draggedItem) handleItemSwipeMove(e, symptom.id);
                            }}
                            onTouchEnd={() => {
                              if (!draggedItem) handleItemSwipeEnd(symptom.id, () => removeSymptom(symptom.id));
                            }}
                            style={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: '8px',
                              background: draggedItem?.id === symptom.id ? '#2d2875' : '#1e1b4b',
                              borderRadius: '5px',
                              transform: `translateX(${swipeOffsets[symptom.id] || 0}px)`,
                              transition: swipeStartRef.current.id === symptom.id ? 'none' : 'transform 0.2s ease',
                            }}
                          >
                            {/* Drag handle */}
                            <div
                              onTouchStart={(e) => handleReorderStart(e, symptom, 'symptom', index, activeSymptoms)}
                              onMouseDown={(e) => handleReorderStart(e, symptom, 'symptom', index, activeSymptoms)}
                              style={{
                                padding: '12px 8px 12px 12px',
                                color: draggedItem?.id === symptom.id ? '#a5b4fc' : '#64748b',
                                fontSize: '16px',
                                cursor: 'grab',
                                touchAction: 'none',
                              }}
                            >
                              â‰¡
                            </div>
                            {/* Clickable text to edit */}
                            <div
                              onClick={() => !draggedItem && startEditingSymptom(symptom)}
                              style={{
                                flex: 1,
                                cursor: 'pointer',
                                padding: '12px 12px 12px 0',
                                color: '#e2e8f0',
                                fontSize: '14px',
                              }}
                            >
                              {symptom.name}
                            </div>
                          </div>
                        </>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {inactiveSymptoms.length > 0 && (
              <div>
                <label style={{
                  color: '#94a3b8',
                  fontSize: '12px',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                }}>Hidden Symptoms</label>
                <p style={{ color: '#64748b', fontSize: '11px', margin: '4px 0 12px 0' }}>
                  Tap + to restore
                </p>
                <div style={{
                  display: 'flex',
                  flexDirection: 'column',
                  gap: '8px',
                }}>
                  {inactiveSymptoms.map((symptom) => (
                    <div
                      key={symptom.id}
                      style={{
                        position: 'relative',
                        overflow: 'hidden',
                        borderRadius: '5px',
                        opacity: 0.7,
                      }}
                    >
                      {editingSymptomId === symptom.id ? (
                        <div style={{
                          display: 'flex',
                          gap: '8px',
                          padding: '4px',
                        }}>
                          <input
                            type="text"
                            value={editingSymptomName}
                            onChange={(e) => setEditingSymptomName(e.target.value)}
                            onKeyDown={(e) => {
                              if (e.key === 'Enter') saveSymptomName();
                              if (e.key === 'Escape') cancelEditingSymptom();
                            }}
                            autoFocus
                            style={{
                              flex: 1,
                              background: 'rgba(99, 102, 241, 0.2)',
                              border: '2px solid rgba(99, 102, 241, 0.5)',
                              borderRadius: '3px',
                              padding: '10px 12px',
                              color: '#fff',
                              fontSize: '14px',
                              outline: 'none',
                            }}
                          />
                          <button
                            onClick={saveSymptomName}
                            style={{
                              background: 'rgba(74, 222, 128, 0.2)',
                              border: '2px solid rgba(74, 222, 128, 0.4)',
                              borderRadius: '3px',
                              padding: '10px 14px',
                              color: '#86efac',
                              fontSize: '14px',
                              cursor: 'pointer',
                            }}
                          >
                            âœ“
                          </button>
                          <button
                            onClick={cancelEditingSymptom}
                            style={{
                              background: 'rgba(239, 68, 68, 0.15)',
                              border: '2px solid rgba(239, 68, 68, 0.3)',
                              borderRadius: '3px',
                              padding: '10px 14px',
                              color: '#fca5a5',
                              fontSize: '14px',
                              cursor: 'pointer',
                            }}
                          >
                            âœ•
                          </button>
                        </div>
                      ) : (
                        <>
                          {/* Non-swipeable content */}
                          <div
                            style={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: '8px',
                              background: 'rgba(15, 23, 42, 0.6)',
                              borderRadius: '5px',
                            }}
                          >
                            {/* Clickable text to edit */}
                            <div
                              onClick={() => startEditingSymptom(symptom)}
                              style={{
                                flex: 1,
                                cursor: 'pointer',
                                padding: '12px',
                                color: '#94a3b8',
                                fontSize: '14px',
                              }}
                            >
                              {symptom.name}
                            </div>
                            {/* Restore button */}
                            <button
                              onClick={() => reactivateSymptom(symptom.id)}
                              style={{
                                background: 'rgba(74, 222, 128, 0.2)',
                                border: 'none',
                                borderRadius: '3px',
                                padding: '8px 12px',
                                marginRight: '8px',
                                color: '#86efac',
                                fontSize: '16px',
                                cursor: 'pointer',
                              }}
                            >
                              +
                            </button>
                          </div>
                        </>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      )}

      {/* History Modal with Sortable Table */}
      {showHistory && (
        <div 
          onClick={closeHistory}
          style={{
            position: 'fixed',
            inset: 0,
            background: 'rgba(0, 0, 0, 0.92)',
            zIndex: 1000,
            overflowY: 'auto',
            padding: '20px',
          }}
        >
          <div 
            onClick={(e) => e.stopPropagation()}
            style={{ maxWidth: '600px', margin: '0 auto' }}
          >
            {/* Header */}
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '16px',
              position: 'sticky',
              top: 0,
              background: 'rgba(12, 10, 29, 0.98)',
              padding: '10px 0',
              zIndex: 10,
            }}>
              <div>
                <h2 style={{ color: '#f8fafc', fontSize: '22px', fontWeight: '700', margin: 0 }}>
                  History
                </h2>
                <p style={{ color: '#64748b', fontSize: '12px', margin: '4px 0 0 0' }}>
                  {sortedHistory.length} entries â€¢ Tap column headers to sort
                </p>
              </div>
              <button
                onClick={closeHistory}
                style={{
                  background: 'rgba(99, 102, 241, 0.2)',
                  border: 'none',
                  borderRadius: '5px',
                  width: '44px',
                  height: '44px',
                  color: '#a5b4fc',
                  fontSize: '20px',
                  cursor: 'pointer',
                }}
              >
                âœ•
              </button>
            </div>

            {sortedHistory.length === 0 ? (
              <p style={{ color: '#64748b', textAlign: 'center', padding: '40px 0' }}>
                No entries recorded yet
              </p>
            ) : (
              <div style={{
                background: 'rgba(30, 27, 75, 0.5)',
                borderRadius: '3px',
                overflow: 'hidden',
                border: '1px solid rgba(99, 102, 241, 0.2)',
              }}>
                <table style={{
                  width: '100%',
                  borderCollapse: 'collapse',
                }}>
                  <thead>
                    <tr style={{ background: 'rgba(30, 27, 75, 0.8)' }}>
                      <th 
                        onClick={() => toggleSort('date')}
                        style={tableHeaderStyle}
                      >
                        Date{getSortIndicator('date')}
                      </th>
                      <th 
                        onClick={() => toggleSort('symptom')}
                        style={tableHeaderStyle}
                      >
                        Symptom{getSortIndicator('symptom')}
                      </th>
                      <th 
                        onClick={() => toggleSort('time')}
                        style={tableHeaderStyle}
                      >
                        Time{getSortIndicator('time')}
                      </th>
                      <th 
                        onClick={() => toggleSort('severity')}
                        style={{...tableHeaderStyle, textAlign: 'center'}}
                      >
                        Severity{getSortIndicator('severity')}
                      </th>
                    </tr>
                  </thead>
                  <tbody>
                    {sortedHistory.map((entry, idx) => (
                      <tr 
                        key={entry.key}
                        style={{
                          background: idx % 2 === 0 ? 'transparent' : 'rgba(99, 102, 241, 0.03)',
                        }}
                      >
                        <td style={{...tableCellStyle, color: '#94a3b8', whiteSpace: 'nowrap'}}>
                          {formatTableDate(entry.date)}
                        </td>
                        <td style={{...tableCellStyle, color: '#e2e8f0', fontWeight: '500'}}>
                          {entry.symptomName}
                        </td>
                        <td style={{...tableCellStyle, color: '#94a3b8'}}>
                          <span style={{ marginRight: '6px', color: '#a5b4fc' }}>
                            {timePeriods.find(t => t.id === entry.time)?.icon}
                          </span>
                          {entry.timePeriodLabel}
                        </td>
                        <td style={{...tableCellStyle, textAlign: 'center'}}>
                          <span style={{
                            display: 'inline-block',
                            minWidth: '28px',
                            padding: '4px 8px',
                            borderRadius: '3px',
                            background: `${severityColors[entry.severity]}20`,
                            color: severityColors[entry.severity],
                            fontWeight: '700',
                            fontSize: '13px',
                          }}>
                            {entry.severity}
                          </span>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        </div>
      )}

      {/* Export Modal */}
      {showExport && (
        <div 
          onClick={closeExport}
          style={{
            position: 'fixed',
            inset: 0,
            background: 'rgba(0, 0, 0, 0.92)',
            zIndex: 1000,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            padding: '20px',
          }}
        >
          <div 
            onClick={(e) => e.stopPropagation()}
            style={{
              background: '#1a1333',
              borderRadius: '5px',
              padding: '24px',
              width: '100%',
              maxWidth: '320px',
              maxHeight: '80vh',
              overflowY: 'auto',
              border: '2px solid rgba(99, 102, 241, 0.3)',
            }}
          >
            <h2 style={{
              color: '#f8fafc',
              fontSize: '20px',
              fontWeight: '700',
              margin: '0 0 16px 0',
              textAlign: 'center',
            }}>
              Export
            </h2>
            
            {/* Copy for AI Section */}
            <div style={{ marginBottom: '20px' }}>
              <label style={{
                color: '#94a3b8',
                fontSize: '11px',
                textTransform: 'uppercase',
                letterSpacing: '1px',
                display: 'block',
                marginBottom: '10px',
              }}>Copy for AI Analysis</label>
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                {[
                  { label: '7 days', days: 7 },
                  { label: '14 days', days: 14 },
                  { label: '30 days', days: 30 },
                  { label: '60 days', days: 60 },
                ].map(({ label, days }) => (
                  <button
                    key={days}
                    onClick={() => copyAIData(days)}
                    style={{
                      background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(99, 102, 241, 0.15) 100%)',
                      border: '1px solid rgba(139, 92, 246, 0.4)',
                      borderRadius: '5px',
                      padding: '12px',
                      color: '#c4b5fd',
                      fontSize: '13px',
                      fontWeight: '600',
                      cursor: 'pointer',
                      textAlign: 'center',
                    }}
                  >
                    ðŸ¤– {label}
                  </button>
                ))}
              </div>
              <p style={{ 
                color: '#64748b', 
                fontSize: '11px', 
                margin: '8px 0 0 0',
                textAlign: 'center',
              }}>
                Copies symptoms + supplements data
              </p>
            </div>
            
            {/* CSV Export Section */}
            <div>
              <label style={{
                color: '#94a3b8',
                fontSize: '11px',
                textTransform: 'uppercase',
                letterSpacing: '1px',
                display: 'block',
                marginBottom: '10px',
              }}>Download CSV</label>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                {[
                  { label: 'Last 7 days', days: 7 },
                  { label: 'Last 30 days', days: 30 },
                  { label: 'Last 3 months', days: 90 },
                  { label: 'Last 6 months', days: 180 },
                  { label: 'Last 12 months', days: 365 },
                  { label: 'All time', days: 99999 },
                ].map(({ label, days }) => (
                  <button
                    key={days}
                    onClick={() => exportCSV(days)}
                    style={{
                      background: 'rgba(99, 102, 241, 0.15)',
                      border: '1px solid rgba(99, 102, 241, 0.3)',
                      borderRadius: '5px',
                      padding: '12px 16px',
                      color: '#e2e8f0',
                      fontSize: '14px',
                      fontWeight: '500',
                      cursor: 'pointer',
                      textAlign: 'left',
                    }}
                  >
                    {label}
                  </button>
                ))}
              </div>
            </div>

            <button
              onClick={closeExport}
              style={{
                width: '100%',
                marginTop: '16px',
                padding: '14px',
                background: 'transparent',
                border: '1px solid rgba(99, 102, 241, 0.3)',
                borderRadius: '3px',
                color: '#94a3b8',
                fontSize: '15px',
                cursor: 'pointer',
              }}
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {/* Insights Modal */}
      {showInsights && (() => {
        const data = getInsights(insightsWindow);
        
        return (
          <div 
            style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'linear-gradient(180deg, #0c0a1d 0%, #1a1333 100%)',
              zIndex: 100,
              overflowY: 'auto',
              padding: '20px 20px 120px 20px',
            }}
          >
            <div 
              style={{ maxWidth: '400px', margin: '0 auto' }}
            >
              {/* Header */}
              <div style={{
                marginBottom: '20px',
              }}>
                <h2 style={{ color: '#f8fafc', fontSize: '24px', fontWeight: '700', margin: 0 }}>
                  Insights
                </h2>
              </div>

              {/* Window Selector */}
              <div style={{
                display: 'flex',
                gap: '8px',
                marginBottom: '20px',
              }}>
                {[30, 60, 90].map(days => (
                  <button
                    key={days}
                    onClick={() => setInsightsWindow(days)}
                    style={{
                      flex: 1,
                      padding: '10px',
                      borderRadius: '5px',
                      border: insightsWindow === days 
                        ? '2px solid rgba(99, 102, 241, 0.6)' 
                        : '1px solid rgba(99, 102, 241, 0.2)',
                      background: insightsWindow === days 
                        ? 'rgba(99, 102, 241, 0.2)' 
                        : 'rgba(99, 102, 241, 0.05)',
                      color: insightsWindow === days ? '#fff' : '#94a3b8',
                      fontSize: '13px',
                      fontWeight: insightsWindow === days ? '600' : '400',
                      cursor: 'pointer',
                    }}
                  >
                    {days} days
                  </button>
                ))}
              </div>

              {!data.hasEnoughData ? (
                <div style={{
                  background: 'rgba(99, 102, 241, 0.1)',
                  border: '1px solid rgba(99, 102, 241, 0.3)',
                  borderRadius: '5px',
                  padding: '32px 24px',
                  textAlign: 'center',
                }}>
                  <div style={{ fontSize: '56px', marginBottom: '16px' }}>ðŸ“Š</div>
                  <p style={{ color: '#e2e8f0', fontSize: '18px', fontWeight: '600', margin: '0 0 8px 0' }}>
                    Keep tracking
                  </p>
                  <p style={{ color: '#94a3b8', fontSize: '14px', margin: 0 }}>
                    {data.daysOfData < data.minDaysNeeded 
                      ? `${data.minDaysNeeded - data.daysOfData} more days needed for ${insightsWindow}-day insights`
                      : `${20 - data.entriesCount} more entries needed`
                    }
                  </p>
                </div>
              ) : data.insights.length === 0 && !data.topCluster ? (
                <div style={{
                  background: 'rgba(99, 102, 241, 0.1)',
                  border: '1px solid rgba(99, 102, 241, 0.3)',
                  borderRadius: '5px',
                  padding: '32px 24px',
                  textAlign: 'center',
                }}>
                  <div style={{ fontSize: '56px', marginBottom: '16px' }}>ðŸ“ˆ</div>
                  <p style={{ color: '#e2e8f0', fontSize: '18px', fontWeight: '600', margin: '0 0 8px 0' }}>
                    No major changes
                  </p>
                  <p style={{ color: '#94a3b8', fontSize: '14px', margin: 0 }}>
                    Your symptoms have been relatively stable over the past {insightsWindow} days.
                  </p>
                </div>
              ) : (
                <>
                  {/* Big number tiles for significant changes */}
                  {data.insights.length > 0 && (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '12px', marginBottom: '20px' }}>
                      {data.insights.map(insight => (
                        <div
                          key={insight.symptomId}
                          style={{
                            background: insight.direction === 'improving' 
                              ? 'linear-gradient(135deg, rgba(34, 197, 94, 0.2) 0%, rgba(74, 222, 128, 0.1) 100%)'
                              : 'linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(251, 146, 60, 0.1) 100%)',
                            border: `2px solid ${insight.direction === 'improving' ? 'rgba(74, 222, 128, 0.4)' : 'rgba(239, 68, 68, 0.4)'}`,
                            borderRadius: '3px',
                            padding: '20px',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '16px',
                          }}
                        >
                          <div style={{
                            fontSize: '36px',
                            fontWeight: '800',
                            color: insight.direction === 'improving' ? '#4ade80' : '#f87171',
                            minWidth: '90px',
                          }}>
                            {insight.direction === 'improving' ? 'â†“' : 'â†‘'}{Math.abs(insight.percentChange)}%
                          </div>
                          <div>
                            <div style={{ color: '#f8fafc', fontSize: '15px', fontWeight: '600' }}>
                              {insight.name}
                            </div>
                            <div style={{ color: '#94a3b8', fontSize: '13px', marginTop: '4px' }}>
                              {insight.direction === 'improving' ? 'Improved' : 'Increased'} over {insightsWindow} days
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}

                  {/* Symptom cluster if significant */}
                  {data.topCluster && (
                    <div style={{
                      background: 'linear-gradient(135deg, rgba(251, 146, 60, 0.15) 0%, rgba(251, 191, 36, 0.1) 100%)',
                      border: '2px solid rgba(251, 146, 60, 0.4)',
                      borderRadius: '3px',
                      padding: '20px',
                      marginBottom: '20px',
                    }}>
                      <div style={{
                        fontSize: '28px',
                        fontWeight: '800',
                        color: '#fbbf24',
                        marginBottom: '8px',
                      }}>
                        {data.topCluster.percent}% of days
                      </div>
                      <div style={{ color: '#f8fafc', fontSize: '14px' }}>
                        <strong>{data.topCluster.names[0]}</strong> and <strong>{data.topCluster.names[1]}</strong> appear together
                      </div>
                      <div style={{ color: '#94a3b8', fontSize: '12px', marginTop: '6px' }}>
                        These symptoms may be related
                      </div>
                    </div>
                  )}

                  {/* AI Analysis Button */}
                  <button
                    onClick={() => {
                      navigator.clipboard.writeText(data.aiPrompt);
                      setLastAction('Copied â€” paste into Claude for AI analysis');
                    }}
                    style={{
                      width: '100%',
                      background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(99, 102, 241, 0.15) 100%)',
                      border: '2px solid rgba(139, 92, 246, 0.4)',
                      borderRadius: '3px',
                      padding: '20px',
                      color: '#c4b5fd',
                      fontSize: '15px',
                      fontWeight: '600',
                      cursor: 'pointer',
                      textAlign: 'center',
                      marginBottom: '20px',
                    }}
                  >
                    <span style={{ fontSize: '20px', marginRight: '8px' }}>ðŸ¤–</span>
                    Copy for AI Analysis
                  </button>

                  <p style={{
                    color: '#64748b',
                    fontSize: '11px',
                    textAlign: 'center',
                    margin: 0,
                  }}>
                    Based on {data.entriesCount} entries over {data.daysOfData} days. For informational purposes only.
                  </p>
                </>
              )}
            </div>
          </div>
        );
      })()}

      {/* Settings - Full Screen */}
      {showSettings && (
        <div 
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'linear-gradient(180deg, #0c0a1d 0%, #1a1333 100%)',
            zIndex: 100,
            overflowY: 'auto',
            padding: '20px 20px 120px 20px',
          }}
        >
          <div style={{ maxWidth: '600px', margin: '0 auto' }}>
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '24px',
            }}>
              <h2 style={{
                color: '#f8fafc',
                fontSize: '24px',
                fontWeight: '700',
                margin: 0,
              }}>
                Settings
              </h2>
            </div>
            
            {/* Cloud Sync (Firebase) */}
            <div style={{ marginBottom: '20px' }}>
              <div style={{
                background: 'rgba(99, 102, 241, 0.1)',
                border: '1px solid rgba(99, 102, 241, 0.3)',
                borderRadius: '3px',
                padding: '14px',
              }}>
                {firebaseError ? (
                  <div style={{ textAlign: 'center', padding: '12px', color: '#94a3b8' }}>
                    <div style={{ marginBottom: '8px', fontSize: '24px' }}>ðŸ”’</div>
                    <div style={{ fontSize: '12px', lineHeight: '1.4' }}>
                      Cloud sync not available in preview.
                    </div>
                    <div style={{ fontSize: '11px', marginTop: '8px', color: '#64748b' }}>
                      Host on your own domain to enable sync.
                    </div>
                  </div>
                ) : (authLoading || !firebaseReady) ? (
                  <div style={{ textAlign: 'center', padding: '20px', color: '#94a3b8' }}>
                    {!firebaseReady ? 'Loading Firebase...' : 'Checking auth...'}
                  </div>
                ) : user ? (
                  <>
                    {/* User Info */}
                    <div style={{
                      display: 'flex',
                      alignItems: 'center',
                      gap: '12px',
                      marginBottom: '12px',
                      paddingBottom: '12px',
                      borderBottom: '1px solid rgba(99, 102, 241, 0.2)',
                    }}>
                      {user.photoURL && (
                        <img 
                          src={user.photoURL} 
                          alt="" 
                          style={{
                            width: '36px',
                            height: '36px',
                            borderRadius: '50%',
                            border: '2px solid rgba(99, 102, 241, 0.4)',
                          }}
                        />
                      )}
                      <div style={{ flex: 1 }}>
                        <div style={{ color: '#f8fafc', fontSize: '14px', fontWeight: '600' }}>
                          {user.displayName || 'User'}
                        </div>
                        <div style={{ color: '#64748b', fontSize: '11px' }}>
                          {user.email}
                        </div>
                      </div>
                      <button
                        onClick={handleSignOut}
                        style={{
                          background: 'rgba(239, 68, 68, 0.15)',
                          border: '1px solid rgba(239, 68, 68, 0.3)',
                          borderRadius: '3px',
                          padding: '6px 10px',
                          color: '#f87171',
                          fontSize: '11px',
                          fontWeight: '600',
                          cursor: 'pointer',
                        }}
                      >
                        Sign Out
                      </button>
                    </div>
                    
                    {/* Sync Status */}
                    <div style={{ 
                      color: '#64748b', 
                      fontSize: '12px', 
                      display: 'flex',
                      alignItems: 'center',
                      gap: '8px',
                      flexWrap: 'wrap',
                    }}>
                      {syncing ? (
                        <>
                          <span style={{ color: '#fbbf24' }}>â³</span>
                          <span>Syncing...</span>
                        </>
                      ) : lastSynced ? (
                        <>
                          <span style={{ color: '#4ade80' }}>â—</span>
                          <span>Auto-sync on â€¢ Last: {lastSynced.toLocaleTimeString()}</span>
                        </>
                      ) : (
                        <>
                          <span style={{ color: '#4ade80' }}>â—</span>
                          <span>Auto-sync enabled</span>
                        </>
                      )}
                    </div>
                    
                    {syncError && (
                      <div style={{ 
                        color: '#f87171', 
                        fontSize: '11px', 
                        marginTop: '8px',
                        background: 'rgba(239, 68, 68, 0.1)',
                        padding: '8px',
                        borderRadius: '3px',
                      }}>
                        âš ï¸ {syncError}
                      </div>
                    )}
                  </>
                ) : (
                  <>
                    {window.location.protocol === 'file:' ? (
                      <div style={{ 
                        color: '#f87171', 
                        fontSize: '12px', 
                        lineHeight: '1.5',
                        background: 'rgba(239, 68, 68, 0.1)',
                        padding: '12px',
                        borderRadius: '3px',
                        border: '1px solid rgba(239, 68, 68, 0.3)',
                      }}>
                        <div style={{ fontWeight: '600', marginBottom: '6px' }}>âš ï¸ Cloud sync unavailable</div>
                        <span>Running from local file. Deploy to GitHub Pages or use a web server for cloud sync.</span>
                      </div>
                    ) : isStandalone() ? (
                      <>
                        <p style={{ 
                          color: '#94a3b8', 
                          fontSize: '12px', 
                          margin: '0 0 12px 0',
                          lineHeight: '1.4',
                        }}>
                          {isSignUp ? 'Create an account' : 'Sign in'} to sync across devices
                        </p>
                        
                        <form onSubmit={handleEmailSignIn} style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
                          <input
                            type="email"
                            placeholder="Email"
                            value={authEmail}
                            onChange={(e) => setAuthEmail(e.target.value)}
                            autoComplete="email"
                            style={{
                              width: '100%',
                              background: 'rgba(30, 27, 75, 0.8)',
                              border: '1px solid rgba(139, 92, 246, 0.3)',
                              borderRadius: '3px',
                              padding: '12px',
                              color: '#f8fafc',
                              fontSize: '14px',
                              outline: 'none',
                            }}
                          />
                          <input
                            type="password"
                            placeholder="Password"
                            value={authPassword}
                            onChange={(e) => setAuthPassword(e.target.value)}
                            autoComplete={isSignUp ? 'new-password' : 'current-password'}
                            style={{
                              width: '100%',
                              background: 'rgba(30, 27, 75, 0.8)',
                              border: '1px solid rgba(139, 92, 246, 0.3)',
                              borderRadius: '3px',
                              padding: '12px',
                              color: '#f8fafc',
                              fontSize: '14px',
                              outline: 'none',
                            }}
                          />
                          <button
                            type="submit"
                            disabled={syncing}
                            style={{
                              width: '100%',
                              background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.3) 0%, rgba(99, 102, 241, 0.3) 100%)',
                              border: '1px solid rgba(139, 92, 246, 0.5)',
                              borderRadius: '3px',
                              padding: '12px 16px',
                              color: '#e2e8f0',
                              fontSize: '14px',
                              fontWeight: '600',
                              cursor: syncing ? 'not-allowed' : 'pointer',
                              opacity: syncing ? 0.7 : 1,
                            }}
                          >
                            {syncing ? 'Please wait...' : isSignUp ? 'Create Account' : 'Sign In'}
                          </button>
                        </form>
                        
                        <button
                          onClick={() => { setIsSignUp(!isSignUp); setSyncError(null); }}
                          style={{
                            display: 'block',
                            width: '100%',
                            textAlign: 'left',
                            background: 'none',
                            border: 'none',
                            color: '#8b5cf6',
                            fontSize: '12px',
                            marginTop: '10px',
                            cursor: 'pointer',
                            padding: 0,
                          }}
                        >
                          {isSignUp ? 'Already have an account? Sign in' : "Don't have an account? Create one"}
                        </button>
                        
                        {!isSignUp && (
                          <button
                            onClick={handleForgotPassword}
                            disabled={syncing}
                            style={{
                              display: 'block',
                              width: '100%',
                              textAlign: 'left',
                              background: 'none',
                              border: 'none',
                              color: '#64748b',
                              fontSize: '12px',
                              marginTop: '8px',
                              cursor: 'pointer',
                              padding: 0,
                            }}
                          >
                            Forgot password?
                          </button>
                        )}
                        
                        {syncError && (
                          <div style={{ 
                            color: '#f87171', 
                            fontSize: '11px', 
                            marginTop: '10px',
                            background: 'rgba(239, 68, 68, 0.1)',
                            padding: '8px',
                            borderRadius: '3px',
                          }}>
                            âš ï¸ {syncError}
                          </div>
                        )}
                      </>
                    ) : (
                      <>
                        <p style={{ 
                          color: '#94a3b8', 
                          fontSize: '12px', 
                          margin: '0 0 12px 0',
                          lineHeight: '1.4',
                        }}>
                          {isSignUp ? 'Create an account' : 'Sign in'} to sync across devices
                        </p>
                        
                        {/* Email/Password Form */}
                        <form onSubmit={handleEmailSignIn} style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
                          <input
                            type="email"
                            placeholder="Email"
                            value={authEmail}
                            onChange={(e) => setAuthEmail(e.target.value)}
                            autoComplete="email"
                            style={{
                              width: '100%',
                              background: 'rgba(30, 27, 75, 0.8)',
                              border: '1px solid rgba(139, 92, 246, 0.3)',
                              borderRadius: '3px',
                              padding: '12px',
                              color: '#f8fafc',
                              fontSize: '14px',
                              outline: 'none',
                            }}
                          />
                          <input
                            type="password"
                            placeholder="Password"
                            value={authPassword}
                            onChange={(e) => setAuthPassword(e.target.value)}
                            autoComplete={isSignUp ? 'new-password' : 'current-password'}
                            style={{
                              width: '100%',
                              background: 'rgba(30, 27, 75, 0.8)',
                              border: '1px solid rgba(139, 92, 246, 0.3)',
                              borderRadius: '3px',
                              padding: '12px',
                              color: '#f8fafc',
                              fontSize: '14px',
                              outline: 'none',
                            }}
                          />
                          <button
                            type="submit"
                            disabled={syncing}
                            style={{
                              width: '100%',
                              background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.3) 0%, rgba(99, 102, 241, 0.3) 100%)',
                              border: '1px solid rgba(139, 92, 246, 0.5)',
                              borderRadius: '3px',
                              padding: '12px 16px',
                              color: '#e2e8f0',
                              fontSize: '14px',
                              fontWeight: '600',
                              cursor: syncing ? 'not-allowed' : 'pointer',
                              opacity: syncing ? 0.7 : 1,
                            }}
                          >
                            {syncing ? 'Please wait...' : isSignUp ? 'Create Account' : 'Sign In'}
                          </button>
                        </form>
                        
                        <button
                          onClick={() => { setIsSignUp(!isSignUp); setSyncError(null); }}
                          style={{
                            display: 'block',
                            width: '100%',
                            textAlign: 'left',
                            background: 'none',
                            border: 'none',
                            color: '#8b5cf6',
                            fontSize: '12px',
                            marginTop: '10px',
                            cursor: 'pointer',
                            padding: 0,
                          }}
                        >
                          {isSignUp ? 'Already have an account? Sign in' : "Don't have an account? Create one"}
                        </button>
                        
                        {!isSignUp && (
                          <button
                            onClick={handleForgotPassword}
                            disabled={syncing}
                            style={{
                              display: 'block',
                              width: '100%',
                              textAlign: 'left',
                              background: 'none',
                              border: 'none',
                              color: '#64748b',
                              fontSize: '12px',
                              marginTop: '8px',
                              cursor: 'pointer',
                              padding: 0,
                            }}
                          >
                            Forgot password?
                          </button>
                        )}
                        
                        {/* Divider */}
                        <div style={{ 
                          display: 'flex', 
                          alignItems: 'center', 
                          margin: '16px 0',
                          gap: '12px',
                        }}>
                          <div style={{ flex: 1, height: '1px', background: 'rgba(100, 116, 139, 0.3)' }} />
                          <span style={{ color: '#64748b', fontSize: '11px' }}>or</span>
                          <div style={{ flex: 1, height: '1px', background: 'rgba(100, 116, 139, 0.3)' }} />
                        </div>
                        
                        {/* Google Sign-In */}
                        <button
                          onClick={handleSignIn}
                          disabled={syncing}
                          style={{
                            width: '100%',
                            background: 'rgba(30, 27, 75, 0.6)',
                            border: '1px solid rgba(100, 116, 139, 0.3)',
                            borderRadius: '3px',
                            padding: '12px 16px',
                            color: '#e2e8f0',
                            fontSize: '14px',
                            fontWeight: '600',
                            cursor: syncing ? 'not-allowed' : 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: '10px',
                            opacity: syncing ? 0.7 : 1,
                          }}
                        >
                          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v3.07h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
                            <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v3.04C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
                            <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
                            <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
                          </svg>
                          Continue with Google
                        </button>
                        
                        {syncError && (
                          <div style={{ 
                            color: '#f87171', 
                            fontSize: '11px', 
                            marginTop: '10px',
                            background: 'rgba(239, 68, 68, 0.1)',
                            padding: '8px',
                            borderRadius: '3px',
                          }}>
                            âš ï¸ {syncError}
                          </div>
                        )}
                      </>
                    )}
                  </>
                )}
              </div>
            </div>
            
            {/* History & Export Row */}
            <div style={{ display: 'flex', gap: '12px', marginBottom: '20px' }}>
              <button
                onClick={() => {
                  setShowSettings(false);
                  setOpenedFromSettings(true);
                  setShowHistory(true);
                }}
                style={{
                  flex: 1,
                  background: 'rgba(99, 102, 241, 0.15)',
                  border: '2px solid rgba(99, 102, 241, 0.3)',
                  borderRadius: '3px',
                  padding: '16px',
                  color: '#a5b4fc',
                  fontSize: '15px',
                  fontWeight: '600',
                  cursor: 'pointer',
                  textAlign: 'center',
                }}
              >
                ðŸ“‹ History
              </button>
              <button
                onClick={() => {
                  setShowSettings(false);
                  setOpenedFromSettings(true);
                  setShowExport(true);
                }}
                style={{
                  flex: 1,
                  background: 'rgba(99, 102, 241, 0.15)',
                  border: '2px solid rgba(99, 102, 241, 0.3)',
                  borderRadius: '3px',
                  padding: '16px',
                  color: '#a5b4fc',
                  fontSize: '15px',
                  fontWeight: '600',
                  cursor: 'pointer',
                  textAlign: 'center',
                }}
              >
                ðŸ“¤ Export
              </button>
            </div>
            
            {/* Manage Symptoms Button */}
            <button
              onClick={() => {
                setShowSettings(false);
                setShowAddSymptom(true);
              }}
              style={{
                width: '100%',
                background: 'rgba(99, 102, 241, 0.15)',
                border: '2px solid rgba(99, 102, 241, 0.3)',
                borderRadius: '3px',
                padding: '16px',
                color: '#a5b4fc',
                fontSize: '15px',
                fontWeight: '500',
                cursor: 'pointer',
                textAlign: 'left',
                marginBottom: '12px',
              }}
            >
              <div style={{ fontWeight: '600', marginBottom: '4px' }}>Manage Symptoms</div>
              <div style={{ fontSize: '12px', opacity: 0.8 }}>
                Add, edit, hide, or restore symptoms
              </div>
            </button>
            
            {/* Manage Stack Button */}
            <button
              onClick={() => {
                setShowSettings(false);
                setShowManageStack(true);
              }}
              style={{
                width: '100%',
                background: 'rgba(99, 102, 241, 0.15)',
                border: '2px solid rgba(99, 102, 241, 0.3)',
                borderRadius: '3px',
                padding: '16px',
                color: '#a5b4fc',
                fontSize: '15px',
                fontWeight: '500',
                cursor: 'pointer',
                textAlign: 'left',
                marginBottom: '20px',
              }}
            >
              <div style={{ fontWeight: '600', marginBottom: '4px' }}>Manage Stack</div>
              <div style={{ fontSize: '12px', opacity: 0.8 }}>
                Add, edit, or remove supplements
              </div>
            </button>
            
            {/* Tracking Mode Selection */}
            <div style={{ marginBottom: '20px' }}>
              <label style={{
                color: '#94a3b8',
                fontSize: '12px',
                textTransform: 'uppercase',
                letterSpacing: '1px',
                display: 'block',
                marginBottom: '12px',
              }}>Tracking Mode</label>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                {Object.entries(trackingModes).map(([key, mode]) => (
                  <button
                    key={key}
                    onClick={() => setTrackingMode(key)}
                    style={{
                      background: trackingMode === key ? 'rgba(99, 102, 241, 0.25)' : 'rgba(99, 102, 241, 0.1)',
                      border: trackingMode === key ? '2px solid rgba(99, 102, 241, 0.6)' : '2px solid rgba(99, 102, 241, 0.2)',
                      borderRadius: '3px',
                      padding: '12px 16px',
                      color: trackingMode === key ? '#fff' : '#a5b4fc',
                      fontSize: '14px',
                      fontWeight: '500',
                      cursor: 'pointer',
                      textAlign: 'left',
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                    }}
                  >
                    <div>
                      <div style={{ fontWeight: '600' }}>{mode.label}</div>
                      <div style={{ fontSize: '11px', opacity: 0.7, marginTop: '2px' }}>{mode.description}</div>
                    </div>
                    {trackingMode === key && <span style={{ fontSize: '16px' }}>âœ“</span>}
                  </button>
                ))}
              </div>
            </div>
            
            {/* iCloud / File Backup */}
            <div style={{ marginBottom: '20px' }}>
              <label style={{
                color: '#94a3b8',
                fontSize: '12px',
                textTransform: 'uppercase',
                letterSpacing: '1px',
                display: 'block',
                marginBottom: '12px',
              }}>iCloud Backup</label>
              
              <div style={{
                background: 'rgba(99, 102, 241, 0.1)',
                border: '1px solid rgba(99, 102, 241, 0.3)',
                borderRadius: '3px',
                padding: '14px',
              }}>
                <p style={{ 
                  color: '#94a3b8', 
                  fontSize: '12px', 
                  margin: '0 0 12px 0',
                  lineHeight: '1.4',
                }}>
                  Save backup to Files â†’ iCloud Drive to sync between devices
                </p>
                
                <div style={{ display: 'flex', gap: '8px' }}>
                  <button
                    onClick={backupToFile}
                    style={{
                      flex: 1,
                      background: 'rgba(74, 222, 128, 0.15)',
                      border: '1px solid rgba(74, 222, 128, 0.3)',
                      borderRadius: '3px',
                      padding: '12px',
                      color: '#86efac',
                      fontSize: '13px',
                      fontWeight: '600',
                      cursor: 'pointer',
                    }}
                  >
                    â†“ Save Backup
                  </button>
                  <button
                    onClick={() => fileInputRef.current?.click()}
                    style={{
                      flex: 1,
                      background: 'rgba(99, 102, 241, 0.15)',
                      border: '1px solid rgba(99, 102, 241, 0.3)',
                      borderRadius: '3px',
                      padding: '12px',
                      color: '#a5b4fc',
                      fontSize: '13px',
                      fontWeight: '600',
                      cursor: 'pointer',
                    }}
                  >
                    â†‘ Load Backup
                  </button>
                </div>
                <input
                  ref={fileInputRef}
                  type="file"
                  accept=".json"
                  onChange={restoreFromFile}
                  style={{ display: 'none' }}
                />
              </div>
            </div>
            
            <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
              <button
                onClick={loadSampleData}
                disabled={isLoading}
                style={{
                  background: isLoading ? 'rgba(99, 102, 241, 0.15)' : 'rgba(74, 222, 128, 0.15)',
                  border: `2px solid ${isLoading ? 'rgba(99, 102, 241, 0.3)' : 'rgba(74, 222, 128, 0.3)'}`,
                  borderRadius: '3px',
                  padding: '16px',
                  color: isLoading ? '#a5b4fc' : '#86efac',
                  fontSize: '15px',
                  fontWeight: '500',
                  cursor: isLoading ? 'wait' : 'pointer',
                  textAlign: 'left',
                  opacity: isLoading ? 0.8 : 1,
                }}
              >
                <div style={{ fontWeight: '600', marginBottom: '4px', display: 'flex', alignItems: 'center', gap: '8px' }}>
                  {isLoading ? 'â³ Loading...' : 'Load Default Data'}
                </div>
                {!isLoading && (
                  <div style={{ fontSize: '12px', opacity: 0.8 }}>
                    Load {defaultSymptoms.length} symptoms + {defaultStackItems.length} supplements with 6 months sample entries
                  </div>
                )}
              </button>

              {!confirmClearData ? (
                <button
                  onClick={clearAllData}
                  style={{
                    background: 'rgba(239, 68, 68, 0.15)',
                    border: '2px solid rgba(239, 68, 68, 0.3)',
                    borderRadius: '3px',
                    padding: '16px',
                    color: '#fca5a5',
                    fontSize: '15px',
                    fontWeight: '500',
                    cursor: 'pointer',
                    textAlign: 'left',
                  }}
                >
                  <div style={{ fontWeight: '600', marginBottom: '4px' }}>Clear All Data</div>
                  <div style={{ fontSize: '12px', opacity: 0.8 }}>
                    Remove all recorded entries (keeps symptoms & stack)
                  </div>
                </button>
              ) : (
                <div style={{
                  background: 'rgba(239, 68, 68, 0.2)',
                  border: '2px solid rgba(239, 68, 68, 0.5)',
                  borderRadius: '3px',
                  padding: '16px',
                }}>
                  <div style={{ color: '#fca5a5', fontWeight: '600', marginBottom: '12px', textAlign: 'center' }}>
                    âš ï¸ Are you sure? This cannot be undone.
                  </div>
                  <div style={{ display: 'flex', gap: '10px' }}>
                    <button
                      onClick={() => setConfirmClearData(false)}
                      style={{
                        flex: 1,
                        background: 'rgba(99, 102, 241, 0.2)',
                        border: '1px solid rgba(99, 102, 241, 0.4)',
                        borderRadius: '3px',
                        padding: '12px',
                        color: '#a5b4fc',
                        fontSize: '14px',
                        fontWeight: '600',
                        cursor: 'pointer',
                      }}
                    >
                      Cancel
                    </button>
                    <button
                      onClick={clearAllData}
                      style={{
                        flex: 1,
                        background: 'rgba(239, 68, 68, 0.3)',
                        border: '1px solid rgba(239, 68, 68, 0.5)',
                        borderRadius: '3px',
                        padding: '12px',
                        color: '#fca5a5',
                        fontSize: '14px',
                        fontWeight: '600',
                        cursor: 'pointer',
                      }}
                    >
                      Yes, Clear All
                    </button>
                  </div>
                </div>
              )}

              {/* App Info & Force Reload */}
              <div style={{
                background: 'rgba(99, 102, 241, 0.1)',
                border: '1px solid rgba(99, 102, 241, 0.3)',
                borderRadius: '3px',
                padding: '16px',
                marginBottom: '16px',
              }}>
                <div style={{ color: '#a5b4fc', fontWeight: '600', marginBottom: '12px' }}>
                  App Info
                </div>
                <div style={{ color: '#94a3b8', fontSize: '13px', marginBottom: '8px' }}>
                  Version: 3.3.4 â€¢ {isStandalone() ? 'PWA' : 'Browser'} â€¢ {window.location.protocol.replace(':', '')}
                </div>
                <div style={{ color: '#64748b', fontSize: '12px', marginBottom: '8px' }}>
                  Cloud sync: {window.location.protocol === 'file:' ? 'âœ— Not available (local file)' : 'âœ“ Available'}
                </div>
                <button
                  onClick={() => {
                    // Clear service worker cache if exists
                    if ('caches' in window) {
                      caches.keys().then(names => {
                        names.forEach(name => caches.delete(name));
                      });
                    }
                    // Force reload from server
                    window.location.reload(true);
                  }}
                  style={{
                    width: '100%',
                    background: 'rgba(99, 102, 241, 0.2)',
                    border: '1px solid rgba(99, 102, 241, 0.4)',
                    borderRadius: '3px',
                    padding: '12px',
                    color: '#a5b4fc',
                    fontSize: '14px',
                    fontWeight: '600',
                    cursor: 'pointer',
                    marginTop: '8px',
                  }}
                >
                  ðŸ”„ Force Reload (Check for Updates)
                </button>
              </div>

              {/* Full Reset */}
              {!confirmFullReset ? (
                <button
                  onClick={fullReset}
                  style={{
                    background: 'rgba(239, 68, 68, 0.25)',
                    border: '2px solid rgba(239, 68, 68, 0.5)',
                    borderRadius: '3px',
                    padding: '16px',
                    color: '#fca5a5',
                    fontSize: '15px',
                    fontWeight: '500',
                    cursor: 'pointer',
                    textAlign: 'left',
                  }}
                >
                  <div style={{ fontWeight: '600', marginBottom: '4px' }}>âš ï¸ Full Reset</div>
                  <div style={{ fontSize: '12px', opacity: 0.8 }}>
                    Remove EVERYTHING - symptoms, stack, all entries, notes
                  </div>
                </button>
              ) : (
                <div style={{
                  background: 'rgba(239, 68, 68, 0.3)',
                  border: '2px solid rgba(239, 68, 68, 0.6)',
                  borderRadius: '3px',
                  padding: '16px',
                }}>
                  <div style={{ color: '#fca5a5', fontWeight: '600', marginBottom: '12px', textAlign: 'center' }}>
                    ðŸš¨ FULL RESET - This will delete EVERYTHING!
                  </div>
                  <div style={{ display: 'flex', gap: '10px' }}>
                    <button
                      onClick={() => setConfirmFullReset(false)}
                      style={{
                        flex: 1,
                        background: 'rgba(99, 102, 241, 0.2)',
                        border: '1px solid rgba(99, 102, 241, 0.4)',
                        borderRadius: '3px',
                        padding: '12px',
                        color: '#a5b4fc',
                        fontSize: '14px',
                        fontWeight: '600',
                        cursor: 'pointer',
                      }}
                    >
                      Cancel
                    </button>
                    <button
                      onClick={fullReset}
                      style={{
                        flex: 1,
                        background: 'rgba(239, 68, 68, 0.4)',
                        border: '1px solid rgba(239, 68, 68, 0.6)',
                        borderRadius: '3px',
                        padding: '12px',
                        color: '#fca5a5',
                        fontSize: '14px',
                        fontWeight: '600',
                        cursor: 'pointer',
                      }}
                    >
                      Yes, Reset Everything
                    </button>
                  </div>
                </div>
              )}
            </div>
            
            {/* Version number */}
            <div style={{
              textAlign: 'center',
              marginTop: '30px',
              paddingTop: '20px',
              borderTop: '1px solid rgba(99, 102, 241, 0.1)',
            }}>
              <span style={{ color: '#475569', fontSize: '12px' }}>
                Symptom Tracker v3.2.0
              </span>
            </div>
          </div>
        </div>
      )}

      {/* Manage Stack - Full Screen */}
      {showManageStack && (
        <div 
          onClick={() => {
            setShowManageStack(false);
            setEditingStackItemId(null);
          }}
          style={{
            position: 'fixed',
            inset: 0,
            background: 'rgba(0, 0, 0, 0.92)',
            zIndex: 1000,
            overflowY: 'auto',
            padding: '20px',
          }}
        >
          <div 
            onClick={(e) => e.stopPropagation()}
            style={{ maxWidth: '400px', margin: '0 auto' }}
          >
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '20px',
            }}>
              <h2 style={{ color: '#f8fafc', fontSize: '22px', fontWeight: '700', margin: 0 }}>
                Manage Stack
              </h2>
              <button
                onClick={() => {
                  setShowManageStack(false);
                  setEditingStackItemId(null);
                }}
                style={{
                  background: 'rgba(99, 102, 241, 0.2)',
                  border: 'none',
                  borderRadius: '5px',
                  width: '44px',
                  height: '44px',
                  color: '#a5b4fc',
                  fontSize: '20px',
                  cursor: 'pointer',
                }}
              >
                âœ•
              </button>
            </div>

            {/* Add new item */}
            <div style={{
              background: 'rgba(30, 27, 75, 0.6)',
              borderRadius: '3px',
              padding: '16px',
              marginBottom: '20px',
            }}>
              <label style={{
                color: '#94a3b8',
                fontSize: '12px',
                textTransform: 'uppercase',
                letterSpacing: '1px',
              }}>Add New Supplement</label>
              <div style={{ display: 'flex', gap: '8px', marginTop: '10px', marginBottom: '10px' }}>
                <input
                  type="text"
                  placeholder="Supplement name"
                  value={newStackItem.name}
                  onChange={(e) => setNewStackItem({...newStackItem, name: e.target.value})}
                  style={{
                    flex: 1,
                    background: 'rgba(15, 23, 42, 0.8)',
                    border: '2px solid rgba(99, 102, 241, 0.3)',
                    borderRadius: '5px',
                    padding: '12px 14px',
                    color: '#f8fafc',
                    fontSize: '15px',
                    outline: 'none',
                  }}
                />
              </div>
              <div style={{ display: 'flex', gap: '8px' }}>
                <input
                  type="text"
                  inputMode="decimal"
                  placeholder="Dose"
                  value={newStackItem.defaultDose}
                  onChange={(e) => setNewStackItem({...newStackItem, defaultDose: e.target.value})}
                  style={{
                    width: '80px',
                    background: 'rgba(15, 23, 42, 0.8)',
                    border: '2px solid rgba(99, 102, 241, 0.3)',
                    borderRadius: '5px',
                    padding: '12px 14px',
                    color: '#f8fafc',
                    fontSize: '15px',
                    textAlign: 'center',
                    outline: 'none',
                  }}
                />
                <select
                  value={newStackItem.unit}
                  onChange={(e) => setNewStackItem({...newStackItem, unit: e.target.value})}
                  style={{
                    width: '80px',
                    background: 'rgba(15, 23, 42, 0.8)',
                    border: '2px solid rgba(99, 102, 241, 0.3)',
                    borderRadius: '5px',
                    padding: '12px 10px',
                    color: '#f8fafc',
                    fontSize: '15px',
                  }}
                >
                  <option value="mg">mg</option>
                  <option value="mcg">mcg</option>
                  <option value="g">g</option>
                  <option value="IU">IU</option>
                  <option value="ml">ml</option>
                  <option value="drops">drops</option>
                  <option value="caps">caps</option>
                </select>
                <button
                  onClick={addStackItem}
                  disabled={!newStackItem.name.trim() || !newStackItem.defaultDose}
                  style={{
                    flex: 1,
                    background: (!newStackItem.name.trim() || !newStackItem.defaultDose) 
                      ? 'rgba(99, 102, 241, 0.3)' 
                      : '#6366f1',
                    border: 'none',
                    borderRadius: '5px',
                    padding: '12px',
                    color: '#fff',
                    fontSize: '14px',
                    fontWeight: '600',
                    cursor: (!newStackItem.name.trim() || !newStackItem.defaultDose) ? 'not-allowed' : 'pointer',
                  }}
                >
                  Add
                </button>
              </div>
            </div>

            {/* Active Items */}
            {stackItems.filter(i => i.active).length > 0 && (
              <div style={{ marginBottom: '20px' }}>
                <label style={{
                  color: '#94a3b8',
                  fontSize: '12px',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                }}>Active Supplements</label>
                <p style={{ color: '#64748b', fontSize: '11px', margin: '4px 0 12px 0' }}>
                  Hold â‰¡ to reorder â€¢ Swipe left to hide â€¢ Tap to edit
                </p>
                <div 
                  style={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '8px',
                    position: 'relative',
                  }}
                  onTouchMove={handleReorderMove}
                  onTouchEnd={handleReorderEnd}
                  onMouseMove={handleReorderMove}
                  onMouseUp={handleReorderEnd}
                  onMouseLeave={handleReorderEnd}
                >
                  {(() => {
                    const activeItems = stackItems.filter(item => item.active).sort((a, b) => (a.order || 0) - (b.order || 0));
                    return activeItems.map((item, index) => (
                    <div
                      key={item.id}
                      data-reorder-item
                      style={{
                        position: 'relative',
                        overflow: draggedItem?.id === item.id ? 'visible' : 'hidden',
                        borderRadius: '5px',
                        ...getReorderTransform(index, 'stack'),
                      }}
                    >
                      {editingStackItemId === item.id ? (
                        <div style={{
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '8px',
                          padding: '4px',
                        }}>
                          <input
                            type="text"
                            value={editingStackItemData.name}
                            onChange={(e) => setEditingStackItemData({...editingStackItemData, name: e.target.value})}
                            autoFocus
                            style={{
                              flex: 1,
                              background: 'rgba(99, 102, 241, 0.2)',
                              border: '2px solid rgba(99, 102, 241, 0.5)',
                              borderRadius: '3px',
                              padding: '10px 12px',
                              color: '#fff',
                              fontSize: '14px',
                              outline: 'none',
                            }}
                          />
                          <div style={{ display: 'flex', gap: '8px' }}>
                            <input
                              type="text"
                              inputMode="decimal"
                              value={editingStackItemData.defaultDose}
                              onChange={(e) => setEditingStackItemData({...editingStackItemData, defaultDose: e.target.value})}
                              style={{
                                width: '70px',
                                background: 'rgba(99, 102, 241, 0.2)',
                                border: '2px solid rgba(99, 102, 241, 0.5)',
                                borderRadius: '3px',
                                padding: '10px 12px',
                                color: '#fff',
                                fontSize: '14px',
                                textAlign: 'center',
                                outline: 'none',
                              }}
                            />
                            <select
                              value={editingStackItemData.unit}
                              onChange={(e) => setEditingStackItemData({...editingStackItemData, unit: e.target.value})}
                              style={{
                                width: '70px',
                                background: 'rgba(99, 102, 241, 0.2)',
                                border: '2px solid rgba(99, 102, 241, 0.5)',
                                borderRadius: '3px',
                                padding: '10px 8px',
                                color: '#fff',
                                fontSize: '14px',
                              }}
                            >
                              <option value="mg">mg</option>
                              <option value="mcg">mcg</option>
                              <option value="g">g</option>
                              <option value="IU">IU</option>
                              <option value="ml">ml</option>
                              <option value="drops">drops</option>
                              <option value="caps">caps</option>
                            </select>
                            <button
                              onClick={saveStackItemEdit}
                              style={{
                                background: 'rgba(74, 222, 128, 0.2)',
                                border: '2px solid rgba(74, 222, 128, 0.4)',
                                borderRadius: '3px',
                                padding: '10px 14px',
                                color: '#86efac',
                                fontSize: '14px',
                                cursor: 'pointer',
                              }}
                            >
                              âœ“
                            </button>
                            <button
                              onClick={cancelEditingStackItem}
                              style={{
                                background: 'rgba(239, 68, 68, 0.15)',
                                border: '2px solid rgba(239, 68, 68, 0.3)',
                                borderRadius: '3px',
                                padding: '10px 14px',
                                color: '#fca5a5',
                                fontSize: '14px',
                                cursor: 'pointer',
                              }}
                            >
                              âœ•
                            </button>
                          </div>
                        </div>
                      ) : (
                        <>
                          {/* Delete action revealed on swipe */}
                          <div style={{
                            position: 'absolute',
                            right: 0,
                            top: 0,
                            bottom: 0,
                            width: '80px',
                            background: '#ef4444',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            borderRadius: '5px',
                          }}>
                            <span style={{ color: '#fff', fontWeight: '600', fontSize: '13px' }}>Hide</span>
                          </div>
                          {/* Swipeable content */}
                          <div
                            onTouchStart={(e) => {
                              if (!draggedItem) handleItemSwipeStart(e, `stack-${item.id}`);
                            }}
                            onTouchMove={(e) => {
                              if (!draggedItem) handleItemSwipeMove(e, `stack-${item.id}`);
                            }}
                            onTouchEnd={() => {
                              if (!draggedItem) handleItemSwipeEnd(`stack-${item.id}`, () => toggleStackItemActive(item.id));
                            }}
                            style={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: '8px',
                              background: draggedItem?.id === item.id ? '#2d2875' : '#1e1b4b',
                              borderRadius: '5px',
                              transform: `translateX(${swipeOffsets[`stack-${item.id}`] || 0}px)`,
                              transition: swipeStartRef.current.id === `stack-${item.id}` ? 'none' : 'transform 0.2s ease',
                            }}
                          >
                            {/* Drag handle */}
                            <div
                              onTouchStart={(e) => handleReorderStart(e, item, 'stack', index, activeItems)}
                              onMouseDown={(e) => handleReorderStart(e, item, 'stack', index, activeItems)}
                              style={{
                                padding: '12px 8px 12px 12px',
                                color: draggedItem?.id === item.id ? '#a5b4fc' : '#64748b',
                                fontSize: '16px',
                                cursor: 'grab',
                                touchAction: 'none',
                              }}
                            >
                              â‰¡
                            </div>
                            {/* Clickable text to edit */}
                            <div 
                              onClick={() => !draggedItem && startEditingStackItem(item)}
                              style={{
                                flex: 1,
                                cursor: 'pointer',
                                padding: '12px 12px 12px 0',
                              }}
                            >
                              <span style={{ color: '#e2e8f0', fontSize: '14px' }}>{item.name}</span>
                              <span style={{ color: '#64748b', fontSize: '12px', marginLeft: '8px' }}>
                                {item.defaultDose} {item.unit}
                              </span>
                            </div>
                          </div>
                        </>
                      )}
                    </div>
                  ));
                  })()}
                </div>
              </div>
            )}

            {/* Inactive Items */}
            {stackItems.filter(i => !i.active).length > 0 && (
              <div>
                <label style={{
                  color: '#94a3b8',
                  fontSize: '12px',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                }}>Inactive Supplements</label>
                <p style={{ color: '#64748b', fontSize: '11px', margin: '4px 0 12px 0' }}>
                  Tap + to restore
                </p>
                <div style={{
                  display: 'flex',
                  flexDirection: 'column',
                  gap: '8px',
                }}>
                  {stackItems.filter(item => !item.active).map((item) => (
                    <div
                      key={item.id}
                      style={{
                        position: 'relative',
                        overflow: 'hidden',
                        borderRadius: '5px',
                        opacity: 0.7,
                      }}
                    >
                      {/* Non-swipeable content */}
                      <div
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          gap: '8px',
                          background: 'rgba(15, 23, 42, 0.6)',
                          borderRadius: '5px',
                        }}
                      >
                        {/* Clickable text to edit */}
                        <div 
                          onClick={() => startEditingStackItem(item)}
                          style={{
                            flex: 1,
                            cursor: 'pointer',
                            padding: '12px',
                          }}
                        >
                          <span style={{ color: '#94a3b8', fontSize: '14px' }}>{item.name}</span>
                          <span style={{ color: '#64748b', fontSize: '12px', marginLeft: '8px' }}>
                            {item.defaultDose} {item.unit}
                          </span>
                        </div>
                        {/* Restore button */}
                        <button
                          onClick={() => toggleStackItemActive(item.id)}
                          style={{
                            background: 'rgba(74, 222, 128, 0.2)',
                            border: 'none',
                            borderRadius: '3px',
                            padding: '8px 12px',
                            marginRight: '8px',
                            color: '#86efac',
                            fontSize: '16px',
                            cursor: 'pointer',
                          }}
                        >
                          +
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      )}

      <style>{`
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes popIn {
          0% { transform: scale(0); opacity: 0; }
          50% { transform: scale(1.2); }
          100% { transform: scale(1); opacity: 1; }
        }
        @keyframes slideDown {
          from { opacity: 0; transform: translateY(-10px); }
          to { opacity: 1; transform: translateY(0); }
        }
        input::placeholder, textarea::placeholder {
          color: #64748b;
        }
        * {
          -webkit-user-select: none;
          -webkit-touch-callout: none;
          -webkit-tap-highlight-color: transparent;
          user-select: none;
        }
        input, textarea {
          -webkit-user-select: text;
          user-select: text;
        }
      `}</style>
    </div>
  );
}



const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <ErrorBoundary>
    <SymptomTrackerMobile />
  </ErrorBoundary>
);
  </script>
</body>
</html>
